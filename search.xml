<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;= V8 &lt; 10.3.163)</title>
      <link href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/"/>
      <url>/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)</a></li><li><strong><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)</a></strong></li></ol><p>The <a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">patch</a> mitigating the exploit from Part 1 was designed to prevent overwriting the WebAssembly code space. However, because we still have access to an arbitrary address write primitive outside the V8 sandbox, we can simply overwrite the flag at runtime to disable this protection. This effectively reverts the environment to the state described in Part 1, restoring our ability to execute arbitrary code.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 20.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)</li></ul><p>Place <a href="v8setup.py"><code>v8setup.py</code></a> and <a href="sandbox.diff"><code>sandbox.diff</code></a> in your working directory and run <code>v8setup.py</code>.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/4a12cb1022ba335ce087dcfe31b261355524b3bf">[sandbox] Add new Memory Corruption API</a> (May 20, 2022)<br>When enabled, this API exposes a new global ‘Sandbox’ object which contains a number of functions and objects that in effect emulate typical memory corruption primitives constructed by exploits. In particular, the ‘MemoryView’ constructor can construct ArrayBuffers instances that can corrupt arbitrary memory inside the sandbox. Further, the getAddressOf(obj) and getSizeInBytesOf(obj) functions can be used respectively to obtain the address (relative to the base of the sandbox) and size of any HeapObject that can be accessed from JavaScript.<br>This API is useful for testing the sandbox, for example to facilitate developing PoC sandbox escapes or writing regression tests. In the future, it may also be used by custom V8 sandbox fuzzers.</p></blockquote><p><code>sandbox.diff</code> corresponds to the commit above, which introduces a new memory corruption API. This allows us to simulate sandboxed exploit primitives for testing purposes.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="WebAssembly-Code-Protection"><a href="#WebAssembly-Code-Protection" class="headerlink" title="WebAssembly Code Protection"></a>WebAssembly Code Protection</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;code-space-access.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeSpaceWriteScope::SetExecutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* code_manager = <span class="built_in">GetWasmCodeManager</span>();</span><br><span class="line">  <span class="keyword">if</span> (code_manager-&gt;<span class="built_in">MemoryProtectionKeysEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(FLAG_wasm_memory_protection_keys);</span><br><span class="line">    code_manager-&gt;<span class="built_in">SetThreadWritable</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAG_wasm_write_protect_code_memory) &#123;</span><br><span class="line marked">    current_native_module_-&gt;<span class="built_in">RemoveWriter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If <code>FLAG_wasm_write_protect_code_memory</code> is set to true, <code>CodeSpaceWriteScope::SetExecutable()</code> calls <code>NativeModule::RemoveWriter()</code> to revoke write permissions whenever write access to the WebAssembly code space is no longer needed.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WasmCodeAllocator::MakeWritable</span><span class="params">(base::AddressRegion region)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!protect_code_memory_) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(<span class="number">0</span>, writers_count_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!region.<span class="built_in">is_empty</span>());</span><br><span class="line">  v8::PageAllocator* page_allocator = <span class="built_in">GetPlatformPageAllocator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Align to commit page size.</span></span><br><span class="line">  <span class="type">size_t</span> commit_page_size = page_allocator-&gt;<span class="built_in">CommitPageSize</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(base::bits::<span class="built_in">IsPowerOfTwo</span>(commit_page_size));</span><br><span class="line">  Address begin = <span class="built_in">RoundDown</span>(region.<span class="built_in">begin</span>(), commit_page_size);</span><br><span class="line">  Address end = <span class="built_in">RoundUp</span>(region.<span class="built_in">end</span>(), commit_page_size);</span><br><span class="line">  region = base::<span class="built_in">AddressRegion</span>(begin, end - begin);</span><br><span class="line"></span><br><span class="line marked">  <span class="built_in">InsertIntoWritableRegions</span>(region, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Write permissions are restored only when necessary. <code>WasmCodeAllocator::MakeWritable()</code> calculates the memory range requiring write access and calls <code>WasmCodeAllocator::InsertIntoWritableRegions()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br></pre></td><td class="code"><pre><span class="line">new_writable_memory += region.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (switch_to_writable) &#123;</span><br><span class="line">  <span class="keyword">for</span> (base::AddressRegion split_range :</span><br><span class="line">       <span class="built_in">SplitRangeByReservationsIfNeeded</span>(region, owned_code_space_)) &#123;</span><br><span class="line">    <span class="built_in">TRACE_HEAP</span>(<span class="string">&quot;Set 0x%&quot;</span> V8PRIxPTR <span class="string">&quot;:0x%&quot;</span> V8PRIxPTR <span class="string">&quot; to RWX\n&quot;</span>,</span><br><span class="line">               split_range.<span class="built_in">begin</span>(), split_range.<span class="built_in">end</span>());</span><br><span class="line marked">    <span class="built_in">CHECK</span>(<span class="built_in">SetPermissions</span>(page_allocator, split_range.<span class="built_in">begin</span>(),</span><br><span class="line marked">                         split_range.<span class="built_in">size</span>(),</span><br><span class="line marked">                         PageAllocator::kReadWriteExecute));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WasmCodeAllocator::InsertIntoWritableRegions()</code> calls <code>SetPermissions()</code> to set the region’s permissions to RWX.</p><p>This mechanism prevents us from writing shellcode to the code space as we did in Part 1, since write permissions likely won’t be active at the moment we attempt our write. However, <code>CodeSpaceWriteScope::SetExecutable()</code> checks <code>FLAG_wasm_write_protect_code_memory</code> every time it is called. If we overwrite this flag to <code>false</code> at runtime, the protection is immediately disabled, allowing us to achieve arbitrary code execution exactly as we did in Part 1.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><h3 id="Obtaining-address-of-FLAG-wasm-write-protect-code-memory"><a href="#Obtaining-address-of-FLAG-wasm-write-protect-code-memory" class="headerlink" title="Obtaining address of FLAG_wasm_write_protect_code_memory"></a>Obtaining address of FLAG_wasm_write_protect_code_memory</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECL_PRIMITIVE_ACCESSORS</span>(isolate_root, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">V</span>(kIsolateRootOffset, kSystemPointerSize)                               \</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;execution&#x2F;isolate.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class contains a collection of data accessible from both C++ runtime</span></span><br><span class="line"><span class="comment">// and compiled code (including assembly stubs, builtins, interpreter bytecode</span></span><br><span class="line"><span class="comment">// handlers and optimized code).</span></span><br><span class="line">IsolateData isolate_data_;</span><br></pre></td></tr></table></figure><p>The <code>WasmInstanceObject</code> class has an accessor, <code>isolate_root</code>, which points to <code>Isolate::isolate_data_</code>.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/1.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">d8.<span class="property">file</span>.<span class="title function_">execute</span>(<span class="string">&quot;v8/test/mjsunit/wasm/wasm-module-builder.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="keyword">new</span> <span class="title class_">WasmModuleBuilder</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line"><span class="keyword">let</span> instance = builder.<span class="title function_">instantiate</span>();</span><br><span class="line">% <span class="title class_">DebugPrint</span>(instance);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/2.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/3.png"></p><figure class="highlight c++"><figcaption><span>src&#x2F;execution&#x2F;isolate-data.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">ExternalReferenceTable external_reference_table_;</span><br></pre></td></tr></table></figure><p>The <code>IsolateData</code> class contains <code>external_reference_table_</code>, which holds pointers to <code>d8</code> execution flags.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/4.png"></p><p>The order of the execution flags remains consistent as long as the V8 version does not change.</p><figure class="highlight c++"><figcaption><span>src&#x2F;flags&#x2F;flag-definitions.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">374</span><br><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_BOOL</span>(builtin_subclassing, <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;subclassing support in built-in methods&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;flags&#x2F;flag-definitions.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">940</span><br><span class="line">941</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_BOOL</span>(wasm_write_protect_code_memory, <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;write protect code memory on the wasm native heap with mprotect&quot;</span>)</span><br></pre></td></tr></table></figure><p>Therefore, we can reliably calculate the address of <code>FLAG_wasm_write_protect_code_memory</code> by using a known flag address found in the <code>IsolateData::external_reference_table_</code>.</p><h3 id="Using-TypedArray"><a href="#Using-TypedArray" class="headerlink" title="Using TypedArray"></a>Using TypedArray</h3><p>The following scripts demonstrate the full exploit chain using <code>TypedArray</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ta.js"><code>pwn_ta.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/pwn_ta.png"></p><h3 id="Using-ArrayBuffer"><a href="#Using-ArrayBuffer" class="headerlink" title="Using ArrayBuffer"></a>Using ArrayBuffer</h3><p>Similarly, here is the implementation using <code>ArrayBuffer</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ab.js"><code>pwn_ab.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/pwn_ab.png"></p><h2 id="Bisection"><a href="#Bisection" class="headerlink" title="Bisection"></a>Bisection</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)<br>Even though this is not a perfect protection, it will make it harder to write to the wasm code space because it’s not permanently RWX.</p></blockquote><p>The patch above enables <code>wasm_write_protect_code_memory</code> by default.</p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/48481a671ac7fed873f8a7e7203862beb6d89abd">[sandbox] Enable sandboxed pointers on Desktop</a> (May 05, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/c50b995e4b57558745aef9dda73dc58c57681811">Revert “[sandbox] Enable sandboxed pointers on Desktop”</a> (May 06, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/31d7838094a853556f345367038fe13252ea9224">Reland “[sandbox] Enable sandboxed pointers on Desktop”</a> (May 06, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/91ab0528f23aaf4d65ae86b7cafdcac65cff6c37">Revert “Reland “[sandbox] Enable sandboxed pointers on Desktop””</a> (May 06, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/9a6a76bf13d3ca1c6788de193afc5513919dd0ed">Reland “Reland “[sandbox] Enable sandboxed pointers on Desktop””</a> (May 10, 2022)</p></blockquote><p>The commits above enabled <code>v8_enable_sandboxed_pointers</code> by default when <code>v8_enable_sandbox</code> is enabled. Consequently, the <code>external_pointer</code> of the <code>JSTypedArray</code> class is no longer stored as a full 8-byte pointer, and the <code>backing_store</code> pointer of the <code>JSArrayBuffer</code> class is now allocated within the V8 sandbox.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/5b9401dde4532719220ac698eef7012cdd371903">[sandbox] Also enable the sandbox outside of Chromium builds</a> (Jun 17, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/c878117fa0a848be0f011f410210ac4026baec05">Revert “[sandbox] Also enable the sandbox outside of Chromium builds”</a> (Jun 20, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/a4d17470ab23b057327d614d032fc05ef70dd683">Reland “[sandbox] Also enable the sandbox outside of Chromium builds”</a> (Jun 21, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/a7329344e52a0af3461aacaa8c538ddf8992e0d6">[sandbox] Disable the sandbox by default outside of Chromium builds</a> (Jul 19, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/a8c27fcc9f9f15a0110a409190a2b514ec86e37f">[sandbox] Enable the sandbox by default in V8 builds</a> (Sep 23, 2022)</p></blockquote><p><code>v8_enable_sandbox</code> was enabled by default for standalone V8 builds in the commits above, while it was already enabled in Chromium builds in the following commit.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/4fb3eae7afa2023057818d11faeefc031b78d444">Turn on v8_enable_virtual_memory_cage for Chromium builds</a> (Oct 4, 2021)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
          <category> exploitation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)</title>
      <link href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/"/>
      <url>/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/</url>
      
        <content type="html"><![CDATA[<ol><li><strong><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)</a></strong></li><li><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)</a></li></ol><p>In this post, I’ll demonstrate a technique to escape the V8 sandbox using <code>TypedArray</code> or <code>ArrayBuffer</code>. This walkthrough assumes we already have standard sandboxed exploit primitives.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 20.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/0ac7e1203fcb957851887fb140dc8a41139846a5"><code>0ac7e1203fcb957851887fb140dc8a41139846a5</code></a> (Feb 15, 2022)</li></ul><p>Place <a href="v8setup.py"><code>v8setup.py</code></a> and <a href="sandbox.diff"><code>sandbox.diff</code></a> into your working directory and run <code>v8setup.py</code>.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/4a12cb1022ba335ce087dcfe31b261355524b3bf">[sandbox] Add new Memory Corruption API</a> (May 20, 2022)<br>When enabled, this API exposes a new global ‘Sandbox’ object which contains a number of functions and objects that in effect emulate typical memory corruption primitives constructed by exploits. In particular, the ‘MemoryView’ constructor can construct ArrayBuffers instances that can corrupt arbitrary memory inside the sandbox. Further, the getAddressOf(obj) and getSizeInBytesOf(obj) functions can be used respectively to obtain the address (relative to the base of the sandbox) and size of any HeapObject that can be accessed from JavaScript.<br>This API is useful for testing the sandbox, for example to facilitate developing PoC sandbox escapes or writing regression tests. In the future, it may also be used by custom V8 sandbox fuzzers.</p></blockquote><p><code>sandbox.diff</code> corresponds to the commit above, which introduces a new memory corruption API. This allows us to simulate sandboxed exploit primitives for testing purposes.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h3><p>The <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> object in JavaScript is represented internally by the <code>JSTypedArray</code> class.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-array-buffer.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSTypedArray</span> extends JSArrayBufferView &#123;</span><br><span class="line">  length: uintptr;</span><br><span class="line">  <span class="comment">// A SandboxedPtr if the sandbox is enabled</span></span><br><span class="line marked">  external_pointer: RawPtr;</span><br><span class="line marked">  base_pointer: ByteArray|Smi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>JSTypedArray</code> class contains two types of pointers:</p><ul><li>The <code>base_pointer</code> points to the <code>ByteArray</code> object that stores the data.</li><li>The <code>external_pointer</code> holds the offset from the <code>base_pointer</code> to the actual address where the data is stored.</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(<span class="number">1</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0x4141414141414141n</span>;</span><br><span class="line">% <span class="title class_">DebugPrint</span>(arr);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/1.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/2.png"></p><p>When accessing the data, V8 calculates the address by adding <code>base_pointer</code> and <code>external_pointer</code>.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/3.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/4.png"></p><p>Since the <code>JSTypedArray</code> object resides within the V8 sandbox, we can:</p><ul><li>Leak the V8 sandbox base address by reading the <code>external_pointer</code> using the sandboxed arbitrary address read primitive.</li><li>Access arbitrary addresses outside the V8 sandbox via the <code>JSTypedArray</code> object by overwriting the <code>external_pointer</code> and the <code>base_pointer</code> with the sandboxed arbitrary address write primitive.</li></ul><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>The <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> object in JavaScript is represented internally by the <code>JSArrayBuffer</code> class.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-array-buffer.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSArrayBuffer</span> extends JSObject &#123;</span><br><span class="line">  byte_length: uintptr;</span><br><span class="line">  max_byte_length: uintptr;</span><br><span class="line">  <span class="comment">// A SandboxedPtr if the sandbox is enabled</span></span><br><span class="line marked">  backing_store: RawPtr;</span><br><span class="line">  extension: RawPtr;</span><br><span class="line">  bit_field: JSArrayBufferFlags;</span><br><span class="line">  <span class="comment">// Pads header size to be a multiple of kTaggedSize.</span></span><br><span class="line">  @<span class="keyword">if</span>(TAGGED_SIZE_8_BYTES) optional_padding: uint32;</span><br><span class="line">  @ifnot(TAGGED_SIZE_8_BYTES) optional_padding: <span class="type">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>JSArrayBuffer</code> class contains a <code>backing_store</code> pointer, which points to the actual address where the data is stored.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line">view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, <span class="number">0x4141414141414141n</span>, <span class="literal">true</span>);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(buf);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/5.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/6.png"></p><p>When accessing the data, V8 reads from the backing store of the <code>JSArrayBuffer</code> object.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/7.png"></p><p>Since the <code>JSArrayBuffer</code> object resides within the V8 sandbox, we can access arbitrary addresses outside the V8 sandbox via the <code>JSArrayBuffer</code> object by overwriting the <code>backing_store</code> pointer using the sandboxed arbitrary address write primitive.</p><h3 id="WebAssembly-Code-Space"><a href="#WebAssembly-Code-Space" class="headerlink" title="WebAssembly Code Space"></a>WebAssembly Code Space</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try up to two times; getting rid of dead JSArrayBuffer allocations might</span></span><br><span class="line"><span class="comment">// require two GCs because the first GC maybe incremental and may have</span></span><br><span class="line"><span class="comment">// floating garbage.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kAllocationRetries = <span class="number">2</span>;</span><br><span class="line">VirtualMemory code_space;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> retries = <span class="number">0</span>;; ++retries) &#123;</span><br><span class="line marked">  code_space = <span class="built_in">TryAllocate</span>(code_vmem_size);</span><br><span class="line">  <span class="keyword">if</span> (code_space.<span class="built_in">IsReserved</span>()) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (retries == kAllocationRetries) &#123;</span><br><span class="line">    V8::<span class="built_in">FatalProcessOutOfMemory</span>(isolate, <span class="string">&quot;NewNativeModule&quot;</span>);</span><br><span class="line">    <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Run one GC, then try the allocation again.</span></span><br><span class="line">  isolate-&gt;<span class="built_in">heap</span>()-&gt;<span class="built_in">MemoryPressureNotification</span>(MemoryPressureLevel::kCritical,</span><br><span class="line">                                              <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When a WebAssembly module is constructed, <code>WasmCodeManager::NewNativeModule()</code> allocates a <code>code_space</code> for that module.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needs_jump_table) &#123;</span><br><span class="line marked">  jump_table = <span class="built_in">CreateEmptyJumpTableInRegionLocked</span>(</span><br><span class="line marked">      JumpTableAssembler::<span class="built_in">SizeForNumberOfSlots</span>(num_wasm_functions), region);</span><br><span class="line">  <span class="built_in">CHECK</span>(region.<span class="built_in">contains</span>(jump_table-&gt;<span class="built_in">instruction_start</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NativeModule::AddCodeSpaceLocked()</code> creates a <code>jump_table</code> at the beginning of the code space. The jump table dispatches execution to the appropriate WebAssembly functions.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Even when we employ W^X with FLAG_wasm_write_protect_code_memory == true,</span></span><br><span class="line"><span class="comment">// code pages need to be initially allocated with RWX permission because of</span></span><br><span class="line"><span class="comment">// concurrent compilation/execution. For this reason there is no distinction</span></span><br><span class="line"><span class="comment">// here based on FLAG_wasm_write_protect_code_memory.</span></span><br><span class="line"><span class="comment">// TODO(dlehmann): This allocates initially as writable and executable, and</span></span><br><span class="line"><span class="comment">// as such is not safe-by-default. In particular, if</span></span><br><span class="line"><span class="comment">// &#123;WasmCodeAllocator::SetWritable(false)&#125; is never called afterwards (e.g.,</span></span><br><span class="line"><span class="comment">// because no &#123;CodeSpaceWriteScope&#125; is created), the writable permission is</span></span><br><span class="line"><span class="comment">// never withdrawn.</span></span><br><span class="line"><span class="comment">// One potential fix is to allocate initially with kReadExecute only, which</span></span><br><span class="line"><span class="comment">// forces all compilation threads to add the missing &#123;CodeSpaceWriteScope&#125;s</span></span><br><span class="line"><span class="comment">// before modification; and/or adding DCHECKs that &#123;CodeSpaceWriteScope&#125; is</span></span><br><span class="line"><span class="comment">// open when calling this method.</span></span><br><span class="line marked">PageAllocator::Permission permission = PageAllocator::kReadWriteExecute;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> success;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">MemoryProtectionKeysEnabled</span>()) &#123;</span><br><span class="line">  <span class="built_in">TRACE_HEAP</span>(</span><br><span class="line">      <span class="string">&quot;Setting rwx permissions and memory protection key %d for 0x%&quot;</span> PRIxPTR</span><br><span class="line">      <span class="string">&quot;:0x%&quot;</span> PRIxPTR <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">      memory_protection_key_, region.<span class="built_in">begin</span>(), region.<span class="built_in">end</span>());</span><br><span class="line">  success = <span class="built_in">SetPermissionsAndMemoryProtectionKey</span>(</span><br><span class="line">      <span class="built_in">GetPlatformPageAllocator</span>(), region, permission, memory_protection_key_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">TRACE_HEAP</span>(<span class="string">&quot;Setting rwx permissions for 0x%&quot;</span> PRIxPTR <span class="string">&quot;:0x%&quot;</span> PRIxPTR <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">             region.<span class="built_in">begin</span>(), region.<span class="built_in">end</span>());</span><br><span class="line marked">  success = <span class="built_in">SetPermissions</span>(<span class="built_in">GetPlatformPageAllocator</span>(), region.<span class="built_in">begin</span>(),</span><br><span class="line marked">                           region.<span class="built_in">size</span>(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code space is mapped with RWX permissions to allow WebAssembly functions to be compiled and executed at runtime.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">d8.<span class="property">file</span>.<span class="title function_">execute</span>(<span class="string">&quot;v8/test/mjsunit/wasm/wasm-module-builder.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="keyword">new</span> <span class="title class_">WasmModuleBuilder</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f1&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f2&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f3&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = builder.<span class="title function_">toModule</span>();</span><br></pre></td></tr></table></figure><p>The JavaScript code above creates a WebAssembly module, which contains three empty functions exported to JavaScript.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/8.png"></p><p>The jump table consists of <code>jmp</code> instructions, where each entry corresponds to a function in the module.</p><p>We can access the exported functions using <a href="https://developer.mozilla.org/docs/WebAssembly/Reference/JavaScript_interface/Instance/exports"><code>WebAssembly.Instance.prototype.exports</code></a>.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="variable language_">module</span>);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(instance.<span class="property">exports</span>);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/9.png"></p><p>Exported WebAssembly functions are represented internally by the <code>JSFunction</code> class, just like any other ordinary JavaScript function.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-function.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class does not use the generated verifier, so if you change anything</span></span><br><span class="line"><span class="comment">// here, please also update JSFunctionVerify in objects-debug.cc.</span></span><br><span class="line">@highestInstanceTypeWithinParentClassRange</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSFunction</span> extends JSFunctionOrBoundFunction &#123;</span><br><span class="line">  shared_function_info: SharedFunctionInfo;</span><br><span class="line">  context: Context;</span><br><span class="line">  feedback_cell: FeedbackCell;</span><br><span class="line marked">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) code: Code;</span><br><span class="line">  <span class="comment">// Space for the following field may or may not be allocated.</span></span><br><span class="line">  prototype_or_initial_map: JSReceiver|Map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>JSFunction</code> class has an accessor named <code>code</code> pointing to a <code>CodeDataContainer</code> object.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;code.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cached value of code().InstructionStart().</span></span><br><span class="line"><span class="comment">// Available only when V8_EXTERNAL_CODE_SPACE is defined.</span></span><br><span class="line"><span class="built_in">DECL_GETTER</span>(code_entry_point, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;code.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">InstructionStart</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">raw_instruction_start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">entry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>The <code>CodeDataContainer</code> class has an accessor named <code>code_entry_point</code> pointing to the execution entry point of the function.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">% <span class="title class_">DebugPrint</span>(instance.<span class="property">exports</span>.<span class="property">f3</span>);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/10.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/11.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.<span class="property">exports</span>.<span class="title function_">f3</span>();</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/12.png"></p><p>At this point, <code>rdi</code> holds the address of the <code>Function</code> object. The instructions from here get the call target corresponding to the function.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/13.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/14.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/15.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/16.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/17.png"></p><p>The instruction pointer eventually hits the third entry of the jump table, which corresponds to <code>f3()</code>, the function we called.</p><p>After we implement an arbitrary address write primitive, we can overwrite the jump table with our shellcode, so that it’s executed when the WebAssembly function is called.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><h3 id="Using-TypedArray"><a href="#Using-TypedArray" class="headerlink" title="Using TypedArray"></a>Using TypedArray</h3><p>The following scripts demonstrate the full exploit chain using <code>TypedArray</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ta.js"><code>pwn_ta.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/pwn_ta.png"></p><h3 id="Using-ArrayBuffer"><a href="#Using-ArrayBuffer" class="headerlink" title="Using ArrayBuffer"></a>Using ArrayBuffer</h3><p>Similarly, here is the implementation using <code>ArrayBuffer</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ab.js"><code>pwn_ab.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/pwn_ab.png"></p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)<br>Even though this is not a perfect protection, it will make it harder to write to the wasm code space because it’s not permanently RWX.</p></blockquote><p>The patch above mitigates the technique demonstrated in this post by preventing WebAssembly code spaces from being permanently RWX. This prevents us from simply overwriting the memory with shellcode.</p>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
          <category> exploitation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
