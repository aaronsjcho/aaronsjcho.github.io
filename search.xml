<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Escaping V8 Sandbox via WebAssembly JIT Spraying: Part 2 (11.0.4 &lt;= V8 &lt; 12.2.170)</title>
      <link href="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/"/>
      <url>/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/escaping-v8-sandbox-via-webassembly-jit-spraying/" title="Escaping V8 Sandbox via WebAssembly JIT Spraying (V8 &lt; 10.6.24)">Escaping V8 Sandbox via WebAssembly JIT Spraying (V8 &lt; 10.6.24)</a></li><li><strong><a href="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/" title="Escaping V8 Sandbox via WebAssembly JIT Spraying: Part 2 (11.0.4 &lt;&#x3D; V8 &lt; 12.2.170)">Escaping V8 Sandbox via WebAssembly JIT Spraying: Part 2 (11.0.4 &lt;&#x3D; V8 &lt; 12.2.170)</a></strong></li></ol><p>In Part 1, I demonstrated how to escape the V8 sandbox by overwriting the call target stored in the <code>WasmInternalFunction</code> object. This technique was eventually mitigated when V8 moved the call target pointer into the External Pointer Table, rendering it immutable from within the sandbox.</p><p>In this follow-up post, I will introduce an alternative technique that exploits the WebAssembly lazy compilation mechanism. By corrupting the <code>jump_table_start</code> field within the <code>WasmInstanceObject</code>—which remained exposed in the sandbox in the affected versions—we can hijack control flow and redirect execution to our JIT-sprayed shellcode.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 22.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/8cf17a14a78cc1276eb42e1b4bb699f705675530"><code>8cf17a14a78cc1276eb42e1b4bb699f705675530</code></a> (Jan 4, 2024)</li></ul><p>Run <a href="v8setup.py"><code>v8setup.py</code></a> in your working directory.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Calling-WebAssembly-Function"><a href="#Calling-WebAssembly-Function" class="headerlink" title="Calling WebAssembly Function"></a>Calling WebAssembly Function</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">d8.<span class="property">file</span>.<span class="title function_">execute</span>(<span class="string">&quot;v8/test/mjsunit/wasm/wasm-module-builder.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="keyword">new</span> <span class="title class_">WasmModuleBuilder</span>();</span><br><span class="line"></span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;g&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]);</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;h&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = builder.<span class="title function_">instantiate</span>();</span><br><span class="line"></span><br><span class="line">instance.<span class="property">exports</span>.<span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><p>The JavaScript code above creates a WebAssembly module containing three functions, and calls the first one.</p><p>The JavaScript function call is handled by <code>Builtins_CallFunction_ReceiverIsAny()</code>, which is generated by <code>Builtins::Generate_CallFunction_ReceiverIsAny()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;builtins&#x2F;builtins-call-gen.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Builtins::Generate_CallFunction_ReceiverIsAny</span><span class="params">(MacroAssembler* masm)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Generate_CallFunction</span>(masm, ConvertReceiverMode::kAny);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;builtins&#x2F;x64&#x2F;builtins-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2567</span><br><span class="line">2568</span><br><span class="line">2569</span><br><span class="line">2570</span><br><span class="line">2571</span><br><span class="line">2572</span><br><span class="line">2573</span><br><span class="line">2574</span><br><span class="line">2575</span><br><span class="line">2576</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------- S t a t e -------------</span></span><br><span class="line"><span class="comment">//  -- rax : the number of arguments</span></span><br><span class="line"><span class="comment">//  -- rdx : the shared function info.</span></span><br><span class="line"><span class="comment">//  -- rdi : the function to call (checked to be a JSFunction)</span></span><br><span class="line"><span class="comment">//  -- rsi : the function context.</span></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function">__ <span class="title">movzxwq</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    rbx, FieldOperand(rdx, SharedFunctionInfo::kFormalParameterCountOffset))</span></span>;</span><br><span class="line marked"><span class="function">__ <span class="title">InvokeFunctionCode</span><span class="params">(rdi, no_reg, rbx, rax, InvokeType::kJump)</span></span>;</span><br></pre></td></tr></table></figure><p><code>Builtins::Generate_CallFunction()</code> calls <code>MacroAssembler::InvokeFunctionCode()</code> to generate the function invocation sequence.</p><figure class="highlight c++"><figcaption><span>src&#x2F;codegen&#x2F;x64&#x2F;macro-assembler-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">3489</span><br><span class="line">3490</span><br><span class="line">3491</span><br><span class="line">3492</span><br><span class="line">3493</span><br><span class="line">3494</span><br><span class="line">3495</span><br><span class="line">3496</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> InvokeType::kCall:</span><br><span class="line">    <span class="built_in">CallJSFunction</span>(function);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> InvokeType::kJump:</span><br><span class="line marked">    <span class="built_in">JumpJSFunction</span>(function);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MacroAssembler::InvokeFunctionCode()</code> calls <code>MacroAssembler::JumpJSFunction()</code> if <code>type</code> is <code>InvokeType::kJump</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;codegen&#x2F;x64&#x2F;macro-assembler-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2813</span><br><span class="line">2814</span><br><span class="line">2815</span><br><span class="line">2816</span><br><span class="line">2817</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When the sandbox is enabled, we can directly fetch the entrypoint pointer</span></span><br><span class="line"><span class="comment">// from the code pointer table instead of going through the Code object. In</span></span><br><span class="line"><span class="comment">// this way, we avoid one memory load on this code path.</span></span><br><span class="line"><span class="built_in">LoadCodeEntrypointViaCodePointer</span>(</span><br><span class="line">    rcx, <span class="built_in">FieldOperand</span>(function_object, JSFunction::kCodeOffset));</span><br></pre></td></tr></table></figure><p><code>MacroAssembler::JumpJSFunction()</code> calls <code>MacroAssembler::LoadCodeEntrypointViaCodePointer()</code> to emit instructions that fetch the entrypoint pointer.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-function.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class does not use the generated verifier, so if you change anything</span></span><br><span class="line"><span class="comment">// here, please also update JSFunctionVerify in objects-debug.cc.</span></span><br><span class="line">@highestInstanceTypeWithinParentClassRange</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSFunction</span> extends JSFunctionOrBoundFunctionOrWrappedFunction &#123;</span><br><span class="line">  <span class="comment">// When the sandbox is enabled, the Code object is referenced through an</span></span><br><span class="line">  <span class="comment">// indirect pointer. Otherwise, it is a regular tagged pointer.</span></span><br><span class="line marked">  @<span class="keyword">if</span>(V8_ENABLE_SANDBOX) code: IndirectPointer&lt;Code&gt;;</span><br><span class="line">  @ifnot(V8_ENABLE_SANDBOX) code: Code;</span><br><span class="line">  shared_function_info: SharedFunctionInfo;</span><br><span class="line">  context: Context;</span><br><span class="line">  feedback_cell: FeedbackCell;</span><br><span class="line">  <span class="comment">// Space for the following field may or may not be allocated.</span></span><br><span class="line">  prototype_or_initial_map: JSReceiver|Map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>include&#x2F;v8-internal.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code pointer handles are shifted by a different amount than indirect pointer</span></span><br><span class="line"><span class="comment">// handles as the tables have a different maximum size.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint32_t</span> kCodePointerHandleShift = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>include&#x2F;v8-internal.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">600</span><br><span class="line">601</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kCodePointerTableEntrySize = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kCodePointerTableEntrySizeLog2 = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;codegen&#x2F;x64&#x2F;macro-assembler-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MacroAssembler::LoadCodeEntrypointViaCodePointer</span><span class="params">(Register destination,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      Operand field_operand)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!<span class="built_in">AreAliased</span>(destination, kScratchRegister));</span><br><span class="line">  <span class="built_in">DCHECK</span>(!field_operand.<span class="built_in">AddressUsesRegister</span>(kScratchRegister));</span><br><span class="line">  <span class="built_in">LoadAddress</span>(kScratchRegister,</span><br><span class="line">              ExternalReference::<span class="built_in">code_pointer_table_address</span>());</span><br><span class="line">  <span class="built_in">movl</span>(destination, field_operand);</span><br><span class="line">  <span class="built_in">shrl</span>(destination, <span class="built_in">Immediate</span>(kCodePointerHandleShift));</span><br><span class="line">  <span class="built_in">shll</span>(destination, <span class="built_in">Immediate</span>(kCodePointerTableEntrySizeLog2));</span><br><span class="line">  <span class="built_in">movq</span>(destination, <span class="built_in">Operand</span>(kScratchRegister, destination, times_1, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/1.png"></p><p><code>Builtins_CallFunction_ReceiverIsAny()</code> reads the code pointer handle stored in the <code>code</code> field of the <code>Function</code> object. It converts the handle into an index to access the corresponding entry of the function in the code pointer table.</p><figure class="highlight c++"><figcaption><span>src&#x2F;sandbox&#x2F;code-pointer-table.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line marked">std::atomic&lt;Address&gt; entrypoint_;</span><br><span class="line"><span class="comment">// The pointer to the Code object also contains the marking bit: since this is</span></span><br><span class="line"><span class="comment">// a tagged pointer to a V8 HeapObject, we know that it will be 4-byte aligned</span></span><br><span class="line"><span class="comment">// and that the LSB should always be set. We therefore use the LSB as marking</span></span><br><span class="line"><span class="comment">// bit. In this way:</span></span><br><span class="line"><span class="comment">//  - When loading the pointer, we only need to perform an unconditional OR 1</span></span><br><span class="line"><span class="comment">//  to get the correctly tagged pointer</span></span><br><span class="line"><span class="comment">//  - When storing the pointer we don&#x27;t need to do anything since the tagged</span></span><br><span class="line"><span class="comment">//  pointer will automatically be marked</span></span><br><span class="line">std::atomic&lt;Address&gt; code_;</span><br></pre></td></tr></table></figure><p>The <code>CodePointerTableEntry</code> class has two fields: <code>entrypoint_</code> and <code>code_</code>. The <code>entrypoint_</code> field holds the entrypoint address, and the <code>code_</code> field holds the address of the <code>Code</code> object corresponding to the function.</p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/2.png"></p><figure class="highlight c++"><figcaption><span>src&#x2F;codegen&#x2F;x64&#x2F;macro-assembler-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2818</span><br><span class="line">2819</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DCHECK_EQ</span>(jump_mode, JumpMode::kJump);</span><br><span class="line"><span class="built_in">jmp</span>(rcx);</span><br></pre></td></tr></table></figure><p>After getting the entrypoint address, <code>Builtins_CallFunction_ReceiverIsAny()</code> jumps to that address, where the generic JS-to-Wasm wrapper starts.</p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/3.png"></p><p><code>Builtins_JSToWasmWrapper()</code> calls <code>Builtins_JSToWasmWrapperAsm()</code> generated by <code>Builtins::Generate_JSToWasmWrapperAsm()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;builtins&#x2F;x64&#x2F;builtins-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">3664</span><br><span class="line">3665</span><br><span class="line">3666</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Builtins::Generate_JSToWasmWrapperAsm</span><span class="params">(MacroAssembler* masm)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">JSToWasmWrapperHelper</span>(masm, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;builtins&#x2F;x64&#x2F;builtins-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">3534</span><br><span class="line">3535</span><br><span class="line">3536</span><br><span class="line">3537</span><br><span class="line">3538</span><br><span class="line">3539</span><br><span class="line">3540</span><br><span class="line">3541</span><br><span class="line">3542</span><br><span class="line">3543</span><br><span class="line">3544</span><br><span class="line">3545</span><br><span class="line">3546</span><br></pre></td><td class="code"><pre><span class="line marked">Register call_target = rdi;</span><br><span class="line"><span class="comment">// param_start should not alias with any parameter registers.</span></span><br><span class="line marked">Register params_start = r11;</span><br><span class="line"><span class="function">__ <span class="title">movq</span><span class="params">(params_start,</span></span></span><br><span class="line"><span class="params"><span class="function">        MemOperand(wrapper_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                   JSToWasmWrapperFrameConstants::kWrapperBufferParamStart))</span></span>;</span><br><span class="line marked">Register params_end = rbx;</span><br><span class="line"><span class="function">__ <span class="title">movq</span><span class="params">(params_end,</span></span></span><br><span class="line"><span class="params"><span class="function">        MemOperand(wrapper_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                   JSToWasmWrapperFrameConstants::kWrapperBufferParamEnd))</span></span>;</span><br><span class="line"><span class="function">__ <span class="title">movq</span><span class="params">(call_target,</span></span></span><br><span class="line"><span class="params"><span class="function">        MemOperand(wrapper_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                   JSToWasmWrapperFrameConstants::kWrapperBufferCallTarget))</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/4.png"></p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/5.png"></p><p><code>Builtins_JSToWasmWrapperAsm()</code> loads the call target address into <code>rdi</code>, the parameter start address into <code>r11</code>, and the parameter end address into <code>rbx</code>.</p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/6.png"></p><p>The call target points to the jump table entry corresponding to the invoked WebAssembly function.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-linkage.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> V8_TARGET_ARCH_X64</span></span><br><span class="line"><span class="comment">// ===========================================================================</span></span><br><span class="line"><span class="comment">// == x64 ====================================================================</span></span><br><span class="line"><span class="comment">// ===========================================================================</span></span><br><span class="line marked"><span class="keyword">constexpr</span> Register kGpParamRegisters[] = &#123;rsi, rax, rdx, rcx, rbx, r9&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> Register kGpReturnRegisters[] = &#123;rax, rdx&#125;;</span><br><span class="line marked"><span class="keyword">constexpr</span> DoubleRegister kFpParamRegisters[] = &#123;xmm1, xmm2, xmm3,</span><br><span class="line marked">                                                xmm4, xmm5, xmm6&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> DoubleRegister kFpReturnRegisters[] = &#123;xmm1, xmm2&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;builtins&#x2F;x64&#x2F;builtins-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">3571</span><br><span class="line">3572</span><br><span class="line">3573</span><br><span class="line">3574</span><br><span class="line">3575</span><br><span class="line">3576</span><br><span class="line">3577</span><br><span class="line">3578</span><br><span class="line">3579</span><br><span class="line">3580</span><br><span class="line">3581</span><br><span class="line">3582</span><br><span class="line">3583</span><br><span class="line">3584</span><br><span class="line">3585</span><br><span class="line">3586</span><br><span class="line">3587</span><br><span class="line">3588</span><br><span class="line">3589</span><br><span class="line">3590</span><br><span class="line">3591</span><br><span class="line">3592</span><br><span class="line">3593</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> next_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arraysize</span>(wasm::kGpParamRegisters); ++i) &#123;</span><br><span class="line">  <span class="comment">// Check that &#123;params_start&#125; does not overlap with any of the parameter</span></span><br><span class="line">  <span class="comment">// registers, so that we don&#x27;t overwrite it by accident with the loads</span></span><br><span class="line">  <span class="comment">// below.</span></span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(params_start, wasm::kGpParamRegisters[i]);</span><br><span class="line">  <span class="function">__ <span class="title">movq</span><span class="params">(wasm::kGpParamRegisters[i], MemOperand(params_start, next_offset))</span></span>;</span><br><span class="line">  next_offset += kSystemPointerSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arraysize</span>(wasm::kFpParamRegisters); ++i) &#123;</span><br><span class="line">  <span class="function">__ <span class="title">Movsd</span><span class="params">(wasm::kFpParamRegisters[i], MemOperand(params_start, next_offset))</span></span>;</span><br><span class="line">  next_offset += kDoubleSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DCHECK_EQ</span>(next_offset, stack_params_offset);</span><br><span class="line"></span><br><span class="line">Register thread_in_wasm_flag_addr = r12;</span><br><span class="line"><span class="function">__ <span class="title">movq</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    thread_in_wasm_flag_addr,</span></span></span><br><span class="line"><span class="params"><span class="function">    MemOperand(kRootRegister, Isolate::thread_in_wasm_flag_address_offset()))</span></span>;</span><br><span class="line"><span class="function">__ <span class="title">movl</span><span class="params">(MemOperand(thread_in_wasm_flag_addr, <span class="number">0</span>), Immediate(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__ <span class="title">call</span><span class="params">(call_target)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/7.png"></p><p>Then, <code>Builtins_JSToWasmWrapperAsm()</code> copies the parameters to the reserved registers, and jumps to the call target address.</p><h3 id="WebAssembly-Lazy-Compilation"><a href="#WebAssembly-Lazy-Compilation" class="headerlink" title="WebAssembly Lazy Compilation"></a>WebAssembly Lazy Compilation</h3><figure class="highlight c++"><figcaption><span>src&#x2F;flags&#x2F;flag-definitions.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1562</span><br><span class="line">1563</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_BOOL</span>(wasm_lazy_compilation, <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;enable lazy compilation for all wasm modules&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/8.png"></p><p>With <code>wasm_lazy_compilation</code> enabled, WebAssembly functions are compiled when they are first called, rather than when the module is instantiated.</p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/9.png"></p><p>The jump table directs execution to <code>Builtins_WasmCompileLazy()</code> generated by <code>Builtins::Generate_WasmCompileLazy()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;builtins&#x2F;x64&#x2F;builtins-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">3130</span><br><span class="line">3131</span><br><span class="line">3132</span><br><span class="line">3133</span><br><span class="line">3134</span><br><span class="line">3135</span><br><span class="line">3136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push arguments for the runtime function.</span></span><br><span class="line"><span class="function">__ <span class="title">Push</span><span class="params">(kWasmInstanceRegister)</span></span>;</span><br><span class="line"><span class="function">__ <span class="title">Push</span><span class="params">(r15)</span></span>;</span><br><span class="line"><span class="comment">// Initialize the JavaScript context with 0. CEntry will use it to</span></span><br><span class="line"><span class="comment">// set the current context on the isolate.</span></span><br><span class="line"><span class="function">__ <span class="title">Move</span><span class="params">(kContextRegister, Smi::zero())</span></span>;</span><br><span class="line marked"><span class="function">__ <span class="title">CallRuntime</span><span class="params">(Runtime::kWasmCompileLazy, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>Builtins_WasmCompileLazy()</code> calls <code>Runtime_WasmCompileLazy()</code> to compile the function.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECL_PRIMITIVE_ACCESSORS</span>(jump_table_start, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;builtins&#x2F;x64&#x2F;builtins-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">3143</span><br><span class="line">3144</span><br><span class="line">3145</span><br><span class="line">3146</span><br><span class="line">3147</span><br><span class="line">3148</span><br><span class="line">3149</span><br><span class="line">3150</span><br><span class="line">3151</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// After the instance register has been restored, we can add the jump table</span></span><br><span class="line">  <span class="comment">// start to the jump table offset already stored in r15.</span></span><br><span class="line">  <span class="function">__ <span class="title">addq</span><span class="params">(r15, MemOperand(kWasmInstanceRegister,</span></span></span><br><span class="line"><span class="params"><span class="function">                          wasm::ObjectAccess::ToTagged(</span></span></span><br><span class="line"><span class="params"><span class="function">                              WasmInstanceObject::kJumpTableStartOffset)))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, jump to the jump table slot for the function.</span></span><br><span class="line"><span class="function">__ <span class="title">jmp</span><span class="params">(r15)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/10.png"></p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/11.png"></p><p>After the compilation is finished, <code>Builtins_WasmCompileLazy()</code> retrieves the function’s jump table slot address from the <code>WasmInstanceObject</code>, and jumps to that address. This time, the jump table transfers control to the function’s compiled code.</p><p>Since the <code>WasmInstanceObject</code> resides within the V8 sandbox, we can hijack control flow by overwriting the <code>jump_table_start</code> field with an arbitrary address before lazy compilation proceeds.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn.wat"><code>pwn.wat</code></a> <a href="pwn.js"><code>pwn.js</code></a></p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/pwn.png"></p><h2 id="Bisection"><a href="#Bisection" class="headerlink" title="Bisection"></a>Bisection</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/29131d5e3ea9cbfeae3e6dc3fd6c4439f0ac4bde">[wasm] Enable lazy compilation by default</a> (Nov 14, 2022)</p></blockquote><p>This technique was introduced in the above commit, which enabled lazy compilation by default.</p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/59acab802a319da23c1c005e062fbc2bab4d348b">[wasm] Introduce WasmTrustedInstanceData</a> (Jan 4, 2024)<br>This CL moves most data from the WasmInstanceObject to a new WasmTrustedInstanceData. As the name suggests, this new object is allocated in the trusted space and can hence hold otherwise-unsafe data (like direct pointers). As the Wasm instance was still storing some unsafe pointers, this CL closes holes in the V8 sandbox, and allows us to land follow-up refactorings to remove more indirections for sandboxing (potentially after moving more data structures to the trusted space).<br>The general idea is that during execution we mostly work with the WasmTrustedInstanceData object. This is passed as a direct pointer to Wasm functions and is stored in Wasm frames. The WasmInstanceObject is the JS-exposed wrapper, which also holds user-defined properties and elements.</p></blockquote><p>The above commit moves some sensitive data including <code>jump_table_start</code> to the newly introduced <code>WasmTrustedInstanceData</code>, which resides outside the V8 sandbox. This prevents overwriting <code>jump_table_start</code> to hijack control flow.</p>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Escaping V8 Sandbox via WebAssembly JIT Spraying (V8 &lt; 10.6.24)</title>
      <link href="/escaping-v8-sandbox-via-webassembly-jit-spraying/"/>
      <url>/escaping-v8-sandbox-via-webassembly-jit-spraying/</url>
      
        <content type="html"><![CDATA[<ol><li><strong><a href="/escaping-v8-sandbox-via-webassembly-jit-spraying/" title="Escaping V8 Sandbox via WebAssembly JIT Spraying (V8 &lt; 10.6.24)">Escaping V8 Sandbox via WebAssembly JIT Spraying (V8 &lt; 10.6.24)</a></strong></li><li><a href="/escaping-v8-sandbox-via-webassembly-jit-spraying-part-2/" title="Escaping V8 Sandbox via WebAssembly JIT Spraying: Part 2 (11.0.4 &lt;&#x3D; V8 &lt; 12.2.170)">Escaping V8 Sandbox via WebAssembly JIT Spraying: Part 2 (11.0.4 &lt;&#x3D; V8 &lt; 12.2.170)</a></li></ol><p>In this post, I will demonstrate a technique to escape the V8 sandbox by applying JIT spraying to WebAssembly. By manipulating the immediate constants in a WebAssembly function and redirecting execution flow, we can force the JIT compiler to emit executable shellcode into memory. This exploit assumes we have already achieved arbitrary read&#x2F;write primitives within the sandbox and focuses on crossing the sandbox boundary to achieve full remote code execution.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 20.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/cb5c1b8a1fd1eee214501ee06fdd4566886803c1"><code>cb5c1b8a1fd1eee214501ee06fdd4566886803c1</code></a> (Jul 26, 2022)</li></ul><p>Run <a href="v8setup.py"><code>v8setup.py</code></a> in your working directory.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Compiling-i64-const"><a href="#Compiling-i64-const" class="headerlink" title="Compiling i64.const"></a>Compiling i64.const</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;function-body-decoder-impl.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2678</span><br><span class="line">2679</span><br><span class="line">2680</span><br><span class="line">2681</span><br><span class="line">2682</span><br><span class="line">2683</span><br><span class="line">2684</span><br><span class="line">2685</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opcode == kExprLocalGet) &#123;</span><br><span class="line">  len = WasmFullDecoder::<span class="built_in">DecodeLocalGet</span>(<span class="keyword">this</span>, opcode);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == kExprI32Const) &#123;</span><br><span class="line">  len = WasmFullDecoder::<span class="built_in">DecodeI32Const</span>(<span class="keyword">this</span>, opcode);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  OpcodeHandler handler = <span class="built_in">GetOpcodeHandler</span>(first_byte);</span><br><span class="line">  len = (*handler)(<span class="keyword">this</span>, opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To decode the WebAssembly <code>i64.const</code> instruction, <code>WasmFullDecoder::DecodeFunctionBody()</code> calls <code>WasmFullDecoder::DecodeI64Const()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;function-body-decoder-impl.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2862</span><br><span class="line">2863</span><br><span class="line">2864</span><br><span class="line">2865</span><br><span class="line">2866</span><br><span class="line">2867</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECODE(name)                                                     \</span></span><br><span class="line"><span class="meta">  static int Decode##name(WasmFullDecoder* decoder, WasmOpcode opcode) &#123; \</span></span><br><span class="line"><span class="meta">    TraceLine trace_msg(decoder);                                        \</span></span><br><span class="line marked"><span class="meta">    return decoder-&gt;Decode##name##Impl(&amp;trace_msg, opcode);              \</span></span><br><span class="line"><span class="meta">  &#125;                                                                      \</span></span><br><span class="line"><span class="meta">  V8_INLINE int Decode##name##Impl(TraceLine* trace_msg, WasmOpcode opcode)</span></span><br></pre></td></tr></table></figure><p><code>WasmFullDecoder::DecodeI64Const()</code> calls <code>WasmFullDecoder::DecodeI64ConstImpl()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;function-body-decoder-impl.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">3344</span><br><span class="line">3345</span><br><span class="line">3346</span><br><span class="line">3347</span><br><span class="line">3348</span><br><span class="line">3349</span><br><span class="line">3350</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECODE</span>(I64Const) &#123;</span><br><span class="line">  <span class="function">ImmI64Immediate&lt;validate&gt; <span class="title">imm</span><span class="params">(<span class="keyword">this</span>, <span class="keyword">this</span>-&gt;pc_ + <span class="number">1</span>)</span></span>;</span><br><span class="line">  Value value = <span class="built_in">CreateValue</span>(kWasmI64);</span><br><span class="line marked">  <span class="built_in">CALL_INTERFACE_IF_OK_AND_REACHABLE</span>(I64Const, &amp;value, imm.value);</span><br><span class="line">  <span class="built_in">Push</span>(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + imm.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WasmFullDecoder::DecodeI64ConstImpl()</code> calls <code>LiftoffCompiler::I64Const()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;baseline&#x2F;liftoff-compiler.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I64Const</span><span class="params">(FullDecoder* decoder, Value* result, <span class="type">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The &#123;VarState&#125; stores constant values as int32_t, thus we only store</span></span><br><span class="line">  <span class="comment">// 64-bit constants in this field if it fits in an int32_t. Larger values</span></span><br><span class="line">  <span class="comment">// cannot be used as immediate value anyway, so we can also just put them in</span></span><br><span class="line">  <span class="comment">// a register immediately.</span></span><br><span class="line">  <span class="type">int32_t</span> value_i32 = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(value);</span><br><span class="line">  <span class="keyword">if</span> (value_i32 == value) &#123;</span><br><span class="line">    <span class="function">__ <span class="title">PushConstant</span><span class="params">(kI64, value_i32)</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LiftoffRegister reg = __ <span class="built_in">GetUnusedRegister</span>(<span class="built_in">reg_class_for</span>(kI64), &#123;&#125;);</span><br><span class="line marked">    <span class="function">__ <span class="title">LoadConstant</span><span class="params">(reg, WasmValue(value))</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">PushRegister</span><span class="params">(kI64, reg)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LiftoffCompiler::I64Const()</code> calls <code>LiftoffAssembler::LoadConstant()</code> to generate instructions loading the constant <code>value</code> into <code>reg</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;baseline&#x2F;x64&#x2F;liftoff-assembler-x64.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LiftoffAssembler::LoadConstant</span><span class="params">(LiftoffRegister reg, WasmValue value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RelocInfo::Mode rmode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (value.<span class="built_in">type</span>().<span class="built_in">kind</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> kI32:</span><br><span class="line">      <span class="keyword">if</span> (value.<span class="built_in">to_i32</span>() == <span class="number">0</span> &amp;&amp; RelocInfo::<span class="built_in">IsNoInfo</span>(rmode)) &#123;</span><br><span class="line">        <span class="built_in">xorl</span>(reg.<span class="built_in">gp</span>(), reg.<span class="built_in">gp</span>());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">movl</span>(reg.<span class="built_in">gp</span>(), <span class="built_in">Immediate</span>(value.<span class="built_in">to_i32</span>(), rmode));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kI64:</span><br><span class="line">      <span class="keyword">if</span> (RelocInfo::<span class="built_in">IsNoInfo</span>(rmode)) &#123;</span><br><span class="line marked">        TurboAssembler::<span class="built_in">Move</span>(reg.<span class="built_in">gp</span>(), value.<span class="built_in">to_i64</span>());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">movq</span>(reg.<span class="built_in">gp</span>(), <span class="built_in">Immediate64</span>(value.<span class="built_in">to_i64</span>(), rmode));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kF32:</span><br><span class="line">      TurboAssembler::<span class="built_in">Move</span>(reg.<span class="built_in">fp</span>(), value.<span class="built_in">to_f32_boxed</span>().<span class="built_in">get_bits</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kF64:</span><br><span class="line">      TurboAssembler::<span class="built_in">Move</span>(reg.<span class="built_in">fp</span>(), value.<span class="built_in">to_f64_boxed</span>().<span class="built_in">get_bits</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LiftoffAssembler::LoadConstant()</code> calls <code>TurboAssembler::Move()</code> if the <code>value</code> type is <code>kI64</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;codegen&#x2F;x64&#x2F;macro-assembler-x64.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(Register dst, <span class="type">intptr_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">xorl</span>(dst, dst);</span><br><span class="line">    <span class="comment">// The following shorter sequence for uint8 causes performance</span></span><br><span class="line">    <span class="comment">// regressions:</span></span><br><span class="line">    <span class="comment">// xorl(dst, dst); movb(dst,</span></span><br><span class="line">    <span class="comment">// Immediate(static_cast&lt;uint32_t&gt;(x)));</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">is_uint32</span>(x)) &#123;</span><br><span class="line">    <span class="built_in">movl</span>(dst, <span class="built_in">Immediate</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(x)));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">is_int32</span>(x)) &#123;</span><br><span class="line">    <span class="comment">// &quot;movq reg64, imm32&quot; is sign extending.</span></span><br><span class="line">    <span class="built_in">movq</span>(dst, <span class="built_in">Immediate</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(x)));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line marked">    <span class="built_in">movq</span>(dst, <span class="built_in">Immediate64</span>(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TurboAssembler::Move()</code> calls <code>Assembler::movq()</code> for a 64-bit integer.</p><figure class="highlight c++"><figcaption><span>src&#x2F;codegen&#x2F;x64&#x2F;assembler-x64.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_INSTRUCTION(instruction)    \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename... Ps&gt;</span>                 \</span></span><br><span class="line"><span class="meta">  void instruction##_tagged(Ps... ps) &#123;     \</span></span><br><span class="line"><span class="meta">    emit_##instruction(ps..., kTaggedSize); \</span></span><br><span class="line"><span class="meta">  &#125;                                         \</span></span><br><span class="line"><span class="meta">                                            \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename... Ps&gt;</span>                 \</span></span><br><span class="line"><span class="meta">  void instruction##l(Ps... ps) &#123;           \</span></span><br><span class="line"><span class="meta">    emit_##instruction(ps..., kInt32Size);  \</span></span><br><span class="line"><span class="meta">  &#125;                                         \</span></span><br><span class="line"><span class="meta">                                            \</span></span><br><span class="line"><span class="meta">  template <span class="string">&lt;typename... Ps&gt;</span>                 \</span></span><br><span class="line"><span class="meta">  void instruction##q(Ps... ps) &#123;           \</span></span><br><span class="line marked"><span class="meta">    emit_##instruction(ps..., kInt64Size);  \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line">  <span class="built_in">ASSEMBLER_INSTRUCTION_LIST</span>(DECLARE_INSTRUCTION)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DECLARE_INSTRUCTION</span></span><br></pre></td></tr></table></figure><p><code>Assembler::movq()</code> calls <code>Assembler::emit_mov()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;codegen&#x2F;x64&#x2F;assembler-x64.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Assembler::emit_mov</span><span class="params">(Register dst, Immediate64 value, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(size, kInt64Size);</span><br><span class="line">  <span class="keyword">if</span> (constpool_.<span class="built_in">TryRecordEntry</span>(value.value_, value.rmode_)) &#123;</span><br><span class="line">    <span class="comment">// Emit rip-relative move with offset = 0</span></span><br><span class="line">    Label label;</span><br><span class="line">    <span class="built_in">emit_mov</span>(dst, <span class="built_in">Operand</span>(&amp;label, <span class="number">0</span>), size);</span><br><span class="line">    <span class="built_in">bind</span>(&amp;label);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    EnsureSpace <span class="built_in">ensure_space</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">emit_rex</span>(dst, size);</span><br><span class="line marked">    <span class="built_in">emit</span>(<span class="number">0xB8</span> | dst.<span class="built_in">low_bits</span>());</span><br><span class="line marked">    <span class="built_in">emit</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Assembler::emit_mov()</code> emits the opcode for the 64-bit <code>mov</code> instruction followed by the raw <code>value</code>.</p><h3 id="JIT-Spraying"><a href="#JIT-Spraying" class="headerlink" title="JIT Spraying"></a>JIT Spraying</h3><p><a href="https://en.wikipedia.org/wiki/JIT_spraying">JIT spraying</a> is an exploitation technique used to bypass the memory protection mechanism. It abuses the JIT compiler emitting immediate constants directly into the compiled code, to insert shellcode into executable memory. We can apply this technique to WebAssembly because Liftoff (the baseline compiler) emits the operand of the <code>i64.const</code> instruction directly into the compiled code, as analyzed above.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(module</span><br><span class="line">  (func (export &quot;f&quot;)</span><br><span class="line">    i64.const 0x4141414141414141</span><br><span class="line">    i64.const 0x4242424242424242</span><br><span class="line">    i64.const 0x4343434343434343</span><br><span class="line">    return</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>After Liftoff compiles the function <code>f</code>, we can observe the following instructions:</p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/1.png"></p><p>We can insert arbitrary 8-byte constant numbers into the middle of the function code. If we can redirect the instruction pointer to the exact location of the constant, those bytes are interpreted as instructions (shellcode).</p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/2.png"></p><p>Consequently, we can execute arbitrary 8-byte shellcode. However, 8 bytes is typically insufficient to execute a complex payload, such as <code>execve(&quot;/bin/sh&quot;, 0, 0)</code>. To overcome this limitation, we can chain several shellcode segments using the relative <a href="https://www.felixcloutier.com/x86/jmp"><code>jmp</code></a> instruction.</p><h3 id="Calling-WebAssembly-Function"><a href="#Calling-WebAssembly-Function" class="headerlink" title="Calling WebAssembly Function"></a>Calling WebAssembly Function</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">d8.<span class="property">file</span>.<span class="title function_">execute</span>(<span class="string">&quot;v8/test/mjsunit/wasm/wasm-module-builder.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="keyword">new</span> <span class="title class_">WasmModuleBuilder</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line"><span class="keyword">let</span> instance = builder.<span class="title function_">instantiate</span>();</span><br><span class="line"></span><br><span class="line">instance.<span class="property">exports</span>.<span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><p>The JavaScript code above creates a WebAssembly module containing an empty function, then calls the exported function.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-function.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSFunction</span> extends JSFunctionOrBoundFunctionOrWrappedFunction &#123;</span><br><span class="line">  shared_function_info: SharedFunctionInfo;</span><br><span class="line">  context: Context;</span><br><span class="line">  feedback_cell: FeedbackCell;</span><br><span class="line marked">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) code: Code;</span><br><span class="line">  <span class="comment">// Space for the following field may or may not be allocated.</span></span><br><span class="line">  prototype_or_initial_map: JSReceiver|Map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/3.png"></p><p>When an exported WebAssembly function is called, the function call handler reads the address of the <code>CodeDataContainer</code> object corresponding to the function from the <code>code</code> field of the <code>Function</code> object.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;code.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layout description.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_DATA_FIELDS(V)                                         \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Strong pointer fields. */</span>                                      \</span></span><br><span class="line"><span class="meta">  V(kPointerFieldsStrongEndOffset, 0)                               \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Weak pointer fields. */</span>                                        \</span></span><br><span class="line"><span class="meta">  V(kNextCodeLinkOffset, kTaggedSize)                               \</span></span><br><span class="line"><span class="meta">  V(kPointerFieldsWeakEndOffset, 0)                                 \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Strong Code pointer fields. */</span>                                 \</span></span><br><span class="line"><span class="meta">  V(kCodeOffset, V8_EXTERNAL_CODE_SPACE_BOOL ? kTaggedSize : 0)     \</span></span><br><span class="line"><span class="meta">  V(kCodePointerFieldsStrongEndOffset, 0)                           \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Raw data fields. */</span>                                            \</span></span><br><span class="line"><span class="meta">  V(kCodeCageBaseUpper32BitsOffset,                                 \</span></span><br><span class="line"><span class="meta">    V8_EXTERNAL_CODE_SPACE_BOOL ? kTaggedSize : 0)                  \</span></span><br><span class="line marked"><span class="meta">  V(kCodeEntryPointOffset,                                          \</span></span><br><span class="line marked"><span class="meta">    V8_EXTERNAL_CODE_SPACE_BOOL ? kExternalPointerSlotSize : 0)     \</span></span><br><span class="line"><span class="meta">  V(kFlagsOffset, V8_EXTERNAL_CODE_SPACE_BOOL ? kUInt16Size : 0)    \</span></span><br><span class="line"><span class="meta">  V(kBuiltinIdOffset, V8_EXTERNAL_CODE_SPACE_BOOL ? kInt16Size : 0) \</span></span><br><span class="line"><span class="meta">  V(kKindSpecificFlagsOffset, kInt32Size)                           \</span></span><br><span class="line"><span class="meta">  V(kUnalignedSize, OBJECT_POINTER_PADDING(kUnalignedSize))         \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Total size. */</span>                                                 \</span></span><br><span class="line"><span class="meta">  V(kSize, 0)</span></span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/4.png"></p><p>Next, the handler retrieves the entrypoint from the <code>CodeDataContainer</code> object and jumps to that address. This is not the WebAssembly function’s entrypoint, but rather the generic JS-to-Wasm wrapper.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-function.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSFunction</span> extends JSFunctionOrBoundFunctionOrWrappedFunction &#123;</span><br><span class="line marked">  shared_function_info: SharedFunctionInfo;</span><br><span class="line">  context: Context;</span><br><span class="line">  feedback_cell: FeedbackCell;</span><br><span class="line">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) code: Code;</span><br><span class="line">  <span class="comment">// Space for the following field may or may not be allocated.</span></span><br><span class="line">  prototype_or_initial_map: JSReceiver|Map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/5.png"></p><p>The wrapper then retrieves the <code>SharedFunctionInfo</code> from the <code>Function</code> object.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;shared-function-info.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@generateBodyDescriptor</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">SharedFunctionInfo</span> extends HeapObject &#123;</span><br><span class="line">  <span class="comment">// function_data field is treated as a custom weak pointer. We visit this</span></span><br><span class="line">  <span class="comment">// field as a weak pointer if there is aged bytecode. If there is no bytecode</span></span><br><span class="line">  <span class="comment">// or if the bytecode is young then we treat it as a strong pointer. This is</span></span><br><span class="line">  <span class="comment">// done to support flushing of bytecode.</span></span><br><span class="line marked">  @customWeakMarking function_data: Object;</span><br><span class="line">  name_or_scope_info: String|NoSharedNameSentinel|ScopeInfo;</span><br><span class="line">  outer_scope_info_or_feedback_metadata: HeapObject;</span><br><span class="line">  script_or_debug_info: Script|DebugInfo|Undefined;</span><br><span class="line">  <span class="comment">// [length]: The function length - usually the number of declared parameters</span></span><br><span class="line">  <span class="comment">// (always without the receiver).</span></span><br><span class="line">  <span class="comment">// Use up to 2^16-2 parameters (16 bits of values, where one is reserved for</span></span><br><span class="line">  <span class="comment">// kDontAdaptArgumentsSentinel). The value is only reliable when the function</span></span><br><span class="line">  <span class="comment">// has been compiled.</span></span><br><span class="line">  length: int16;</span><br><span class="line">  <span class="comment">// [formal_parameter_count]: The number of declared parameters (or the special</span></span><br><span class="line">  <span class="comment">// value kDontAdaptArgumentsSentinel to indicate that arguments are passed</span></span><br><span class="line">  <span class="comment">// unaltered).</span></span><br><span class="line">  <span class="comment">// In contrast to [length], formal_parameter_count includes the receiver.</span></span><br><span class="line">  formal_parameter_count: uint16;</span><br><span class="line">  function_token_offset: uint16;</span><br><span class="line">  <span class="comment">// [expected_nof_properties]: Expected number of properties for the</span></span><br><span class="line">  <span class="comment">// function. The value is only reliable when the function has been compiled.</span></span><br><span class="line">  expected_nof_properties: uint8;</span><br><span class="line">  flags2: SharedFunctionInfoFlags2;</span><br><span class="line">  flags: SharedFunctionInfoFlags;</span><br><span class="line">  <span class="comment">// [function_literal_id] - uniquely identifies the FunctionLiteral this</span></span><br><span class="line">  <span class="comment">// SharedFunctionInfo represents within its script, or -1 if this</span></span><br><span class="line">  <span class="comment">// SharedFunctionInfo object doesn&#x27;t correspond to a parsed FunctionLiteral.</span></span><br><span class="line">  function_literal_id: int32;</span><br><span class="line">  <span class="comment">// [unique_id] - For --log-maps purposes, an identifier that&#x27;s persistent</span></span><br><span class="line">  <span class="comment">// even if the GC moves this SharedFunctionInfo.</span></span><br><span class="line">  @<span class="keyword">if</span>(V8_SFI_HAS_UNIQUE_ID) unique_id: int32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/6.png"></p><p>From there, it obtains the address of the <code>WasmExportedFunctionData</code> object.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">WasmFunctionData</span> extends HeapObject &#123;</span><br><span class="line">  <span class="comment">// The wasm-internal representation of this function object.</span></span><br><span class="line marked">  internal: WasmInternalFunction;</span><br><span class="line">  <span class="comment">// Used for calling this function from JavaScript.</span></span><br><span class="line">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) wrapper_code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) wrapper_code: Code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">WasmExportedFunctionData</span> extends WasmFunctionData &#123;</span><br><span class="line">  <span class="comment">// This is the instance that exported the function (which in case of</span></span><br><span class="line">  <span class="comment">// imported and re-exported functions is different from the instance</span></span><br><span class="line">  <span class="comment">// where the function is defined -- for the latter see WasmFunctionData::ref).</span></span><br><span class="line">  instance: WasmInstanceObject;</span><br><span class="line">  function_index: Smi;</span><br><span class="line">  signature: Foreign;</span><br><span class="line">  wrapper_budget: Smi;</span><br><span class="line">  <span class="comment">// The remaining fields are for fast calling from C++. The contract is</span></span><br><span class="line">  <span class="comment">// that they are lazily populated, and either all will be present or none.</span></span><br><span class="line">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) c_wrapper_code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) c_wrapper_code: Code;</span><br><span class="line">  packed_args_size: Smi;</span><br><span class="line">  <span class="comment">// Functions returned by suspender.returnPromiseOnSuspend() have this field</span></span><br><span class="line">  <span class="comment">// set to the host suspender object.</span></span><br><span class="line">  suspend: Smi;  <span class="comment">// Boolean.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/7.png"></p><p>Subsequently, it accesses the <code>WasmInternalFunction</code> referenced by the <code>WasmExportedFunctionData</code> object.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;foreign.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">Foreign</span> extends HeapObject &#123;</span><br><span class="line marked">  foreign_address: ExternalPointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the representation that is used internally by wasm to represent</span></span><br><span class="line"><span class="comment">// function references.</span></span><br><span class="line"><span class="comment">// The &#123;foreign_address&#125; field inherited from &#123;Foreign&#125; points to the call</span></span><br><span class="line"><span class="comment">// target.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">WasmInternalFunction</span> extends Foreign &#123;</span><br><span class="line">  <span class="comment">// This is the &quot;reference&quot; value that must be passed along in the &quot;instance&quot;</span></span><br><span class="line">  <span class="comment">// register when calling the given function. It is either the target instance</span></span><br><span class="line">  <span class="comment">// (for wasm functions), or a WasmApiFunctionRef object (for functions defined</span></span><br><span class="line">  <span class="comment">// through the JS or C APIs).</span></span><br><span class="line">  <span class="comment">// For imported functions, this value equals the respective entry in</span></span><br><span class="line">  <span class="comment">// the module&#x27;s imported_function_refs array.</span></span><br><span class="line">  ref: WasmInstanceObject|WasmApiFunctionRef;</span><br><span class="line">  <span class="comment">// The external (JS) representation of this function reference.</span></span><br><span class="line">  external: JSFunction|Undefined;</span><br><span class="line">  <span class="comment">// This field is used when the call target is null.</span></span><br><span class="line">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) code: Code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/8.png"></p><p>Finally, it reads the call target address from the <code>WasmInternalFunction</code> object and jumps to that address, which points to the WebAssembly jump table.</p><p>The <code>WasmInternalFunction</code> object resides within the V8 sandbox (heap), but its <code>foreign_address</code> field points to the executable machine code (JIT page) located outside the sandbox. By overwriting this field with the address of our shellcode (which we can calculate by leaking the code address of <code>f()</code> and adding the offset to our constants) using a sandboxed arbitrary write primitive, we can hijack control flow and execute the shellcode.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn.wat"><code>pwn.wat</code></a> <a href="pwn.js"><code>pwn.js</code></a></p><p><img src="/escaping-v8-sandbox-via-webassembly-jit-spraying/pwn.png"></p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/2eb73988a37a60520a0f8e0b1109edbcc0b91415">[sandbox] Refactor and sandboxify WasmInternalFunction::call_target</a> (Jul 26, 2022)<br>This CL refactors WasmInternalFunction to no longer inherit from Foreign but instead contain a (sandboxed) ExternalPointer field for the call target.</p></blockquote><p>The above patch moves the call target address into the external pointer table, which is located outside the V8 sandbox and referenced by an index (handle), thus preventing the direct overwrite.</p>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;= V8 &lt; 10.3.163)</title>
      <link href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/"/>
      <url>/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)</a></li><li><strong><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)</a></strong></li></ol><p>The <a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">patch</a> mitigating the exploit from Part 1 was designed to prevent overwriting the WebAssembly code space. However, because we still have access to an arbitrary address write primitive outside the V8 sandbox, we can simply overwrite the flag at runtime to disable this protection. This effectively reverts the environment to the state described in Part 1, restoring our ability to execute arbitrary code.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 20.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)</li></ul><p>Place <a href="v8setup.py"><code>v8setup.py</code></a> and <a href="sandbox.diff"><code>sandbox.diff</code></a> in your working directory and run <code>v8setup.py</code>.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/4a12cb1022ba335ce087dcfe31b261355524b3bf">[sandbox] Add new Memory Corruption API</a> (May 20, 2022)<br>When enabled, this API exposes a new global ‘Sandbox’ object which contains a number of functions and objects that in effect emulate typical memory corruption primitives constructed by exploits. In particular, the ‘MemoryView’ constructor can construct ArrayBuffers instances that can corrupt arbitrary memory inside the sandbox. Further, the getAddressOf(obj) and getSizeInBytesOf(obj) functions can be used respectively to obtain the address (relative to the base of the sandbox) and size of any HeapObject that can be accessed from JavaScript.<br>This API is useful for testing the sandbox, for example to facilitate developing PoC sandbox escapes or writing regression tests. In the future, it may also be used by custom V8 sandbox fuzzers.</p></blockquote><p><code>sandbox.diff</code> corresponds to the commit above, which introduces a new memory corruption API. This allows us to simulate sandboxed exploit primitives for testing purposes.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="WebAssembly-Code-Protection"><a href="#WebAssembly-Code-Protection" class="headerlink" title="WebAssembly Code Protection"></a>WebAssembly Code Protection</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;code-space-access.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeSpaceWriteScope::SetExecutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* code_manager = <span class="built_in">GetWasmCodeManager</span>();</span><br><span class="line">  <span class="keyword">if</span> (code_manager-&gt;<span class="built_in">MemoryProtectionKeysEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(FLAG_wasm_memory_protection_keys);</span><br><span class="line">    code_manager-&gt;<span class="built_in">SetThreadWritable</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAG_wasm_write_protect_code_memory) &#123;</span><br><span class="line marked">    current_native_module_-&gt;<span class="built_in">RemoveWriter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If <code>FLAG_wasm_write_protect_code_memory</code> is set to true, <code>CodeSpaceWriteScope::SetExecutable()</code> calls <code>NativeModule::RemoveWriter()</code> to revoke write permissions whenever write access to the WebAssembly code space is no longer needed.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WasmCodeAllocator::MakeWritable</span><span class="params">(base::AddressRegion region)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!protect_code_memory_) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(<span class="number">0</span>, writers_count_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!region.<span class="built_in">is_empty</span>());</span><br><span class="line">  v8::PageAllocator* page_allocator = <span class="built_in">GetPlatformPageAllocator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Align to commit page size.</span></span><br><span class="line">  <span class="type">size_t</span> commit_page_size = page_allocator-&gt;<span class="built_in">CommitPageSize</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(base::bits::<span class="built_in">IsPowerOfTwo</span>(commit_page_size));</span><br><span class="line">  Address begin = <span class="built_in">RoundDown</span>(region.<span class="built_in">begin</span>(), commit_page_size);</span><br><span class="line">  Address end = <span class="built_in">RoundUp</span>(region.<span class="built_in">end</span>(), commit_page_size);</span><br><span class="line">  region = base::<span class="built_in">AddressRegion</span>(begin, end - begin);</span><br><span class="line"></span><br><span class="line marked">  <span class="built_in">InsertIntoWritableRegions</span>(region, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Write permissions are restored only when necessary. <code>WasmCodeAllocator::MakeWritable()</code> calculates the memory range requiring write access and calls <code>WasmCodeAllocator::InsertIntoWritableRegions()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br></pre></td><td class="code"><pre><span class="line">new_writable_memory += region.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (switch_to_writable) &#123;</span><br><span class="line">  <span class="keyword">for</span> (base::AddressRegion split_range :</span><br><span class="line">       <span class="built_in">SplitRangeByReservationsIfNeeded</span>(region, owned_code_space_)) &#123;</span><br><span class="line">    <span class="built_in">TRACE_HEAP</span>(<span class="string">&quot;Set 0x%&quot;</span> V8PRIxPTR <span class="string">&quot;:0x%&quot;</span> V8PRIxPTR <span class="string">&quot; to RWX\n&quot;</span>,</span><br><span class="line">               split_range.<span class="built_in">begin</span>(), split_range.<span class="built_in">end</span>());</span><br><span class="line marked">    <span class="built_in">CHECK</span>(<span class="built_in">SetPermissions</span>(page_allocator, split_range.<span class="built_in">begin</span>(),</span><br><span class="line marked">                         split_range.<span class="built_in">size</span>(),</span><br><span class="line marked">                         PageAllocator::kReadWriteExecute));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WasmCodeAllocator::InsertIntoWritableRegions()</code> calls <code>SetPermissions()</code> to set the region’s permissions to RWX.</p><p>This mechanism prevents us from writing shellcode to the code space as we did in Part 1, since write permissions likely won’t be active at the moment we attempt our write. However, <code>CodeSpaceWriteScope::SetExecutable()</code> checks <code>FLAG_wasm_write_protect_code_memory</code> every time it is called. If we overwrite this flag to <code>false</code> at runtime, the protection is immediately disabled, allowing us to achieve arbitrary code execution exactly as we did in Part 1.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><h3 id="Obtaining-address-of-FLAG-wasm-write-protect-code-memory"><a href="#Obtaining-address-of-FLAG-wasm-write-protect-code-memory" class="headerlink" title="Obtaining address of FLAG_wasm_write_protect_code_memory"></a>Obtaining address of FLAG_wasm_write_protect_code_memory</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECL_PRIMITIVE_ACCESSORS</span>(isolate_root, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">V</span>(kIsolateRootOffset, kSystemPointerSize)                               \</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;execution&#x2F;isolate.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class contains a collection of data accessible from both C++ runtime</span></span><br><span class="line"><span class="comment">// and compiled code (including assembly stubs, builtins, interpreter bytecode</span></span><br><span class="line"><span class="comment">// handlers and optimized code).</span></span><br><span class="line">IsolateData isolate_data_;</span><br></pre></td></tr></table></figure><p>The <code>WasmInstanceObject</code> class has an accessor, <code>isolate_root</code>, which points to <code>Isolate::isolate_data_</code>.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/1.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">d8.<span class="property">file</span>.<span class="title function_">execute</span>(<span class="string">&quot;v8/test/mjsunit/wasm/wasm-module-builder.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="keyword">new</span> <span class="title class_">WasmModuleBuilder</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line"><span class="keyword">let</span> instance = builder.<span class="title function_">instantiate</span>();</span><br><span class="line">% <span class="title class_">DebugPrint</span>(instance);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/2.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/3.png"></p><figure class="highlight c++"><figcaption><span>src&#x2F;execution&#x2F;isolate-data.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">ExternalReferenceTable external_reference_table_;</span><br></pre></td></tr></table></figure><p>The <code>IsolateData</code> class contains <code>external_reference_table_</code>, which holds pointers to <code>d8</code> execution flags.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/4.png"></p><p>The order of the execution flags remains consistent as long as the V8 version does not change.</p><figure class="highlight c++"><figcaption><span>src&#x2F;flags&#x2F;flag-definitions.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">374</span><br><span class="line">375</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_BOOL</span>(builtin_subclassing, <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;subclassing support in built-in methods&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;flags&#x2F;flag-definitions.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">940</span><br><span class="line">941</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_BOOL</span>(wasm_write_protect_code_memory, <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;write protect code memory on the wasm native heap with mprotect&quot;</span>)</span><br></pre></td></tr></table></figure><p>Therefore, we can reliably calculate the address of <code>FLAG_wasm_write_protect_code_memory</code> by using a known flag address found in the <code>IsolateData::external_reference_table_</code>.</p><h3 id="Using-TypedArray"><a href="#Using-TypedArray" class="headerlink" title="Using TypedArray"></a>Using TypedArray</h3><p>The following scripts demonstrate the full exploit chain using <code>TypedArray</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ta.js"><code>pwn_ta.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/pwn_ta.png"></p><h3 id="Using-ArrayBuffer"><a href="#Using-ArrayBuffer" class="headerlink" title="Using ArrayBuffer"></a>Using ArrayBuffer</h3><p>Similarly, here is the implementation using <code>ArrayBuffer</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ab.js"><code>pwn_ab.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/pwn_ab.png"></p><h2 id="Bisection"><a href="#Bisection" class="headerlink" title="Bisection"></a>Bisection</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)<br>Even though this is not a perfect protection, it will make it harder to write to the wasm code space because it’s not permanently RWX.</p></blockquote><p>The patch above enables <code>wasm_write_protect_code_memory</code> by default.</p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/48481a671ac7fed873f8a7e7203862beb6d89abd">[sandbox] Enable sandboxed pointers on Desktop</a> (May 05, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/c50b995e4b57558745aef9dda73dc58c57681811">Revert “[sandbox] Enable sandboxed pointers on Desktop”</a> (May 06, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/31d7838094a853556f345367038fe13252ea9224">Reland “[sandbox] Enable sandboxed pointers on Desktop”</a> (May 06, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/91ab0528f23aaf4d65ae86b7cafdcac65cff6c37">Revert “Reland “[sandbox] Enable sandboxed pointers on Desktop””</a> (May 06, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/9a6a76bf13d3ca1c6788de193afc5513919dd0ed">Reland “Reland “[sandbox] Enable sandboxed pointers on Desktop””</a> (May 10, 2022)</p></blockquote><p>The commits above enabled <code>v8_enable_sandboxed_pointers</code> by default when <code>v8_enable_sandbox</code> is enabled. Consequently, the <code>external_pointer</code> of the <code>JSTypedArray</code> class is no longer stored as a full 8-byte pointer, and the <code>backing_store</code> pointer of the <code>JSArrayBuffer</code> class is now allocated within the V8 sandbox.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/5b9401dde4532719220ac698eef7012cdd371903">[sandbox] Also enable the sandbox outside of Chromium builds</a> (Jun 17, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/c878117fa0a848be0f011f410210ac4026baec05">Revert “[sandbox] Also enable the sandbox outside of Chromium builds”</a> (Jun 20, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/a4d17470ab23b057327d614d032fc05ef70dd683">Reland “[sandbox] Also enable the sandbox outside of Chromium builds”</a> (Jun 21, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/a7329344e52a0af3461aacaa8c538ddf8992e0d6">[sandbox] Disable the sandbox by default outside of Chromium builds</a> (Jul 19, 2022)<br><a href="https://chromium.googlesource.com/v8/v8.git/+/a8c27fcc9f9f15a0110a409190a2b514ec86e37f">[sandbox] Enable the sandbox by default in V8 builds</a> (Sep 23, 2022)</p></blockquote><p><code>v8_enable_sandbox</code> was enabled by default for standalone V8 builds in the commits above, while it was already enabled in Chromium builds in the following commit.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/4fb3eae7afa2023057818d11faeefc031b78d444">Turn on v8_enable_virtual_memory_cage for Chromium builds</a> (Oct 4, 2021)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)</title>
      <link href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/"/>
      <url>/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/</url>
      
        <content type="html"><![CDATA[<ol><li><strong><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer (V8 &lt; 10.0.138)</a></strong></li><li><a href="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer-part-2/" title="Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)">Escaping the V8 Sandbox by Overwriting WebAssembly Jump Table via TypedArray or ArrayBuffer: Part 2 (10.0.138 &lt;&#x3D; V8 &lt; 10.3.163)</a></li></ol><p>In this post, I will demonstrate a technique to escape the V8 sandbox using <code>TypedArray</code> or <code>ArrayBuffer</code>. This walkthrough assumes we already have standard sandboxed exploit primitives.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 20.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/0ac7e1203fcb957851887fb140dc8a41139846a5"><code>0ac7e1203fcb957851887fb140dc8a41139846a5</code></a> (Feb 15, 2022)</li></ul><p>Place <a href="v8setup.py"><code>v8setup.py</code></a> and <a href="sandbox.diff"><code>sandbox.diff</code></a> into your working directory and run <code>v8setup.py</code>.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/4a12cb1022ba335ce087dcfe31b261355524b3bf">[sandbox] Add new Memory Corruption API</a> (May 20, 2022)<br>When enabled, this API exposes a new global ‘Sandbox’ object which contains a number of functions and objects that in effect emulate typical memory corruption primitives constructed by exploits. In particular, the ‘MemoryView’ constructor can construct ArrayBuffers instances that can corrupt arbitrary memory inside the sandbox. Further, the getAddressOf(obj) and getSizeInBytesOf(obj) functions can be used respectively to obtain the address (relative to the base of the sandbox) and size of any HeapObject that can be accessed from JavaScript.<br>This API is useful for testing the sandbox, for example to facilitate developing PoC sandbox escapes or writing regression tests. In the future, it may also be used by custom V8 sandbox fuzzers.</p></blockquote><p><code>sandbox.diff</code> corresponds to the commit above, which introduces a new memory corruption API. This allows us to simulate sandboxed exploit primitives for testing purposes.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h3><p>The <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> object in JavaScript is represented internally by the <code>JSTypedArray</code> class.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-array-buffer.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSTypedArray</span> extends JSArrayBufferView &#123;</span><br><span class="line">  length: uintptr;</span><br><span class="line">  <span class="comment">// A SandboxedPtr if the sandbox is enabled</span></span><br><span class="line marked">  external_pointer: RawPtr;</span><br><span class="line marked">  base_pointer: ByteArray|Smi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>JSTypedArray</code> class contains two types of pointers:</p><ul><li>The <code>base_pointer</code> points to the <code>ByteArray</code> object that stores the data.</li><li>The <code>external_pointer</code> holds the offset from the <code>base_pointer</code> to the actual address where the data is stored.</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(<span class="number">1</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0x4141414141414141n</span>;</span><br><span class="line">% <span class="title class_">DebugPrint</span>(arr);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/1.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/2.png"></p><p>When accessing the data, V8 calculates the address by adding <code>base_pointer</code> and <code>external_pointer</code>.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/3.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/4.png"></p><p>Since the <code>JSTypedArray</code> object resides within the V8 sandbox, we can:</p><ul><li>Leak the V8 sandbox base address by reading the <code>external_pointer</code> using the sandboxed arbitrary address read primitive.</li><li>Access arbitrary addresses outside the V8 sandbox via the <code>JSTypedArray</code> object by overwriting the <code>external_pointer</code> and the <code>base_pointer</code> with the sandboxed arbitrary address write primitive.</li></ul><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>The <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> object in JavaScript is represented internally by the <code>JSArrayBuffer</code> class.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-array-buffer.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSArrayBuffer</span> extends JSObject &#123;</span><br><span class="line">  byte_length: uintptr;</span><br><span class="line">  max_byte_length: uintptr;</span><br><span class="line">  <span class="comment">// A SandboxedPtr if the sandbox is enabled</span></span><br><span class="line marked">  backing_store: RawPtr;</span><br><span class="line">  extension: RawPtr;</span><br><span class="line">  bit_field: JSArrayBufferFlags;</span><br><span class="line">  <span class="comment">// Pads header size to be a multiple of kTaggedSize.</span></span><br><span class="line">  @<span class="keyword">if</span>(TAGGED_SIZE_8_BYTES) optional_padding: uint32;</span><br><span class="line">  @ifnot(TAGGED_SIZE_8_BYTES) optional_padding: <span class="type">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>JSArrayBuffer</code> class contains a <code>backing_store</code> pointer, which points to the actual address where the data is stored.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line">view.<span class="title function_">setBigUint64</span>(<span class="number">0</span>, <span class="number">0x4141414141414141n</span>, <span class="literal">true</span>);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(buf);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/5.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/6.png"></p><p>When accessing the data, V8 reads from the backing store of the <code>JSArrayBuffer</code> object.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/7.png"></p><p>Since the <code>JSArrayBuffer</code> object resides within the V8 sandbox, we can access arbitrary addresses outside the V8 sandbox by overwriting the <code>backing_store</code> pointer using the sandboxed arbitrary address write primitive.</p><h3 id="WebAssembly-Code-Space"><a href="#WebAssembly-Code-Space" class="headerlink" title="WebAssembly Code Space"></a>WebAssembly Code Space</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try up to two times; getting rid of dead JSArrayBuffer allocations might</span></span><br><span class="line"><span class="comment">// require two GCs because the first GC maybe incremental and may have</span></span><br><span class="line"><span class="comment">// floating garbage.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kAllocationRetries = <span class="number">2</span>;</span><br><span class="line">VirtualMemory code_space;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> retries = <span class="number">0</span>;; ++retries) &#123;</span><br><span class="line marked">  code_space = <span class="built_in">TryAllocate</span>(code_vmem_size);</span><br><span class="line">  <span class="keyword">if</span> (code_space.<span class="built_in">IsReserved</span>()) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (retries == kAllocationRetries) &#123;</span><br><span class="line">    V8::<span class="built_in">FatalProcessOutOfMemory</span>(isolate, <span class="string">&quot;NewNativeModule&quot;</span>);</span><br><span class="line">    <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Run one GC, then try the allocation again.</span></span><br><span class="line">  isolate-&gt;<span class="built_in">heap</span>()-&gt;<span class="built_in">MemoryPressureNotification</span>(MemoryPressureLevel::kCritical,</span><br><span class="line">                                              <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When a WebAssembly module is constructed, <code>WasmCodeManager::NewNativeModule()</code> allocates a <code>code_space</code> for that module.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needs_jump_table) &#123;</span><br><span class="line marked">  jump_table = <span class="built_in">CreateEmptyJumpTableInRegionLocked</span>(</span><br><span class="line marked">      JumpTableAssembler::<span class="built_in">SizeForNumberOfSlots</span>(num_wasm_functions), region);</span><br><span class="line">  <span class="built_in">CHECK</span>(region.<span class="built_in">contains</span>(jump_table-&gt;<span class="built_in">instruction_start</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NativeModule::AddCodeSpaceLocked()</code> creates a <code>jump_table</code> at the beginning of the code space. The jump table dispatches execution to the appropriate WebAssembly functions.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Even when we employ W^X with FLAG_wasm_write_protect_code_memory == true,</span></span><br><span class="line"><span class="comment">// code pages need to be initially allocated with RWX permission because of</span></span><br><span class="line"><span class="comment">// concurrent compilation/execution. For this reason there is no distinction</span></span><br><span class="line"><span class="comment">// here based on FLAG_wasm_write_protect_code_memory.</span></span><br><span class="line"><span class="comment">// TODO(dlehmann): This allocates initially as writable and executable, and</span></span><br><span class="line"><span class="comment">// as such is not safe-by-default. In particular, if</span></span><br><span class="line"><span class="comment">// &#123;WasmCodeAllocator::SetWritable(false)&#125; is never called afterwards (e.g.,</span></span><br><span class="line"><span class="comment">// because no &#123;CodeSpaceWriteScope&#125; is created), the writable permission is</span></span><br><span class="line"><span class="comment">// never withdrawn.</span></span><br><span class="line"><span class="comment">// One potential fix is to allocate initially with kReadExecute only, which</span></span><br><span class="line"><span class="comment">// forces all compilation threads to add the missing &#123;CodeSpaceWriteScope&#125;s</span></span><br><span class="line"><span class="comment">// before modification; and/or adding DCHECKs that &#123;CodeSpaceWriteScope&#125; is</span></span><br><span class="line"><span class="comment">// open when calling this method.</span></span><br><span class="line marked">PageAllocator::Permission permission = PageAllocator::kReadWriteExecute;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> success;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">MemoryProtectionKeysEnabled</span>()) &#123;</span><br><span class="line">  <span class="built_in">TRACE_HEAP</span>(</span><br><span class="line">      <span class="string">&quot;Setting rwx permissions and memory protection key %d for 0x%&quot;</span> PRIxPTR</span><br><span class="line">      <span class="string">&quot;:0x%&quot;</span> PRIxPTR <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">      memory_protection_key_, region.<span class="built_in">begin</span>(), region.<span class="built_in">end</span>());</span><br><span class="line">  success = <span class="built_in">SetPermissionsAndMemoryProtectionKey</span>(</span><br><span class="line">      <span class="built_in">GetPlatformPageAllocator</span>(), region, permission, memory_protection_key_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">TRACE_HEAP</span>(<span class="string">&quot;Setting rwx permissions for 0x%&quot;</span> PRIxPTR <span class="string">&quot;:0x%&quot;</span> PRIxPTR <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">             region.<span class="built_in">begin</span>(), region.<span class="built_in">end</span>());</span><br><span class="line marked">  success = <span class="built_in">SetPermissions</span>(<span class="built_in">GetPlatformPageAllocator</span>(), region.<span class="built_in">begin</span>(),</span><br><span class="line marked">                           region.<span class="built_in">size</span>(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code space is mapped with RWX permissions to allow WebAssembly functions to be compiled and executed at runtime.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">d8.<span class="property">file</span>.<span class="title function_">execute</span>(<span class="string">&quot;v8/test/mjsunit/wasm/wasm-module-builder.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> builder = <span class="keyword">new</span> <span class="title class_">WasmModuleBuilder</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f1&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f2&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line">builder.<span class="title function_">addFunction</span>(<span class="string">&quot;f3&quot;</span>, <span class="title function_">makeSig</span>([], [])).<span class="title function_">addBody</span>([]).<span class="title function_">exportFunc</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = builder.<span class="title function_">toModule</span>();</span><br></pre></td></tr></table></figure><p>The JavaScript code above creates a WebAssembly module, which contains three empty functions exported to JavaScript.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/8.png"></p><p>The jump table consists of <code>jmp</code> instructions, where each entry corresponds to a function in the module.</p><p>We can access the exported functions using <a href="https://developer.mozilla.org/docs/WebAssembly/Reference/JavaScript_interface/Instance/exports"><code>WebAssembly.Instance.prototype.exports</code></a>.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="variable language_">module</span>);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(instance.<span class="property">exports</span>);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/9.png"></p><p>Exported WebAssembly functions are represented internally by the <code>JSFunction</code> class, just like any other ordinary JavaScript function.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-function.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class does not use the generated verifier, so if you change anything</span></span><br><span class="line"><span class="comment">// here, please also update JSFunctionVerify in objects-debug.cc.</span></span><br><span class="line">@highestInstanceTypeWithinParentClassRange</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSFunction</span> extends JSFunctionOrBoundFunction &#123;</span><br><span class="line">  shared_function_info: SharedFunctionInfo;</span><br><span class="line">  context: Context;</span><br><span class="line">  feedback_cell: FeedbackCell;</span><br><span class="line marked">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) code: Code;</span><br><span class="line">  <span class="comment">// Space for the following field may or may not be allocated.</span></span><br><span class="line">  prototype_or_initial_map: JSReceiver|Map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>JSFunction</code> class has an accessor named <code>code</code> pointing to a <code>CodeDataContainer</code> object.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;code.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cached value of code().InstructionStart().</span></span><br><span class="line"><span class="comment">// Available only when V8_EXTERNAL_CODE_SPACE is defined.</span></span><br><span class="line"><span class="built_in">DECL_GETTER</span>(code_entry_point, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;code.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">InstructionStart</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">raw_instruction_start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">entry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>The <code>CodeDataContainer</code> class has an accessor named <code>code_entry_point</code> pointing to the execution entry point of the function.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">% <span class="title class_">DebugPrint</span>(instance.<span class="property">exports</span>.<span class="property">f3</span>);</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/10.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/11.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance.<span class="property">exports</span>.<span class="title function_">f3</span>();</span><br></pre></td></tr></table></figure><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/12.png"></p><p>At this point, <code>rdi</code> holds the address of the <code>Function</code> object. The instructions from here get the call target corresponding to the function.</p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/13.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/14.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/15.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/16.png"></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/17.png"></p><p>The instruction pointer eventually hits the third entry of the jump table, which corresponds to <code>f3()</code>, the function we called.</p><p>After we implement an arbitrary address write primitive, we can overwrite the jump table with our shellcode, so that it’s executed when the WebAssembly function is called.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><h3 id="Using-TypedArray"><a href="#Using-TypedArray" class="headerlink" title="Using TypedArray"></a>Using TypedArray</h3><p>The following scripts demonstrate the full exploit chain using <code>TypedArray</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ta.js"><code>pwn_ta.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/pwn_ta.png"></p><h3 id="Using-ArrayBuffer"><a href="#Using-ArrayBuffer" class="headerlink" title="Using ArrayBuffer"></a>Using ArrayBuffer</h3><p>Similarly, here is the implementation using <code>ArrayBuffer</code>:</p><p><a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn_ab.js"><code>pwn_ab.js</code></a></p><p><img src="/escaping-the-v8-sandbox-by-overwriting-webassembly-jump-table-via-typedarray-or-arraybuffer/pwn_ab.png"></p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)<br>Even though this is not a perfect protection, it will make it harder to write to the wasm code space because it’s not permanently RWX.</p></blockquote><p>The patch above mitigates the technique demonstrated in this post by preventing WebAssembly code spaces from being permanently RWX. This prevents us from simply overwriting the memory with shellcode.</p>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
