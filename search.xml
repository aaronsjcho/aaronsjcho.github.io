<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Escaping V8 Sandbox via TypedArray and WebAssembly Code Space: Part 2 (10.0.138 &lt;= V8 &lt; 10.3.163)</title>
      <link href="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/"/>
      <url>/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/</url>
      
        <content type="html"><![CDATA[<p>The <a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">patch</a> for <a href="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/" title="Escaping V8 Sandbox via TypedArray and WebAssembly Code Space: Part 1 (V8 &lt; 10.0.138)">part 1</a> enables <code>wasm_write_protect_code_memory</code> by default to prohibit WebAssembly code space from being overwritten, but it’s not yet a perfect protection, as the commit message states. We can still implement an unsandboxed AAW primitive via <code>TypedArray</code>, and overwrite <code>wasm_write_protect_code_memory</code> with <code>false</code> at runtime to disable the feature manually. Then, we can achieve arbitrary code execution in the same way as part 1.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 22.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/7e9715d8a955214788475dd33a16312ba4d5c3da">7e9715d8a955214788475dd33a16312ba4d5c3da</a> (May 10, 2022)</li></ul><p>Place <a href="v8setup.py"><code>v8setup.py</code></a> and <a href="sandbox.diff"><code>sandbox.diff</code></a> in your working directory, then run <code>v8setup.py</code>.</p><p><code>sandbox.diff</code> is identical to the change in <a href="https://chromium.googlesource.com/v8/v8.git/+/4a12cb1022ba335ce087dcfe31b261355524b3bf">[sandbox] Add new Memory Corruption API</a> (May 20, 2022), which introduced a new memory corruption API that allows us to simulate a vulnerability and implement essential exploit primitives within the sandbox.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="WebAssembly-code-protection-via-mprotect"><a href="#WebAssembly-code-protection-via-mprotect" class="headerlink" title="WebAssembly code protection via mprotect"></a>WebAssembly code protection via mprotect</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;code-space-access.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeSpaceWriteScope::SetExecutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* code_manager = <span class="built_in">GetWasmCodeManager</span>();</span><br><span class="line">  <span class="keyword">if</span> (code_manager-&gt;<span class="built_in">MemoryProtectionKeysEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(FLAG_wasm_memory_protection_keys);</span><br><span class="line">    code_manager-&gt;<span class="built_in">SetThreadWritable</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAG_wasm_write_protect_code_memory) &#123;</span><br><span class="line marked">    current_native_module_-&gt;<span class="built_in">RemoveWriter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CodeSpaceWriteScope::SetExecutable()</code> calls <code>NativeModule::RemoveWriter()</code> to keep write permission not set while there’s no need to write anything to the WebAssembly code space.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WasmCodeAllocator::MakeWritable</span><span class="params">(base::AddressRegion region)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!protect_code_memory_) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(<span class="number">0</span>, writers_count_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!region.<span class="built_in">is_empty</span>());</span><br><span class="line">  v8::PageAllocator* page_allocator = <span class="built_in">GetPlatformPageAllocator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Align to commit page size.</span></span><br><span class="line">  <span class="type">size_t</span> commit_page_size = page_allocator-&gt;<span class="built_in">CommitPageSize</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(base::bits::<span class="built_in">IsPowerOfTwo</span>(commit_page_size));</span><br><span class="line">  Address begin = <span class="built_in">RoundDown</span>(region.<span class="built_in">begin</span>(), commit_page_size);</span><br><span class="line">  Address end = <span class="built_in">RoundUp</span>(region.<span class="built_in">end</span>(), commit_page_size);</span><br><span class="line">  region = base::<span class="built_in">AddressRegion</span>(begin, end - begin);</span><br><span class="line"></span><br><span class="line marked">  <span class="built_in">InsertIntoWritableRegions</span>(region, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The permission is restored by <code>WasmCodeAllocator::MakeWritable()</code> if necessary. It calculates the range of the <code>region</code> that needs the write permission and calls <code>WasmCodeAllocator::InsertIntoWritableRegions()</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br></pre></td><td class="code"><pre><span class="line">new_writable_memory += region.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (switch_to_writable) &#123;</span><br><span class="line">  <span class="keyword">for</span> (base::AddressRegion split_range :</span><br><span class="line">       <span class="built_in">SplitRangeByReservationsIfNeeded</span>(region, owned_code_space_)) &#123;</span><br><span class="line">    <span class="built_in">TRACE_HEAP</span>(<span class="string">&quot;Set 0x%&quot;</span> V8PRIxPTR <span class="string">&quot;:0x%&quot;</span> V8PRIxPTR <span class="string">&quot; to RWX\n&quot;</span>,</span><br><span class="line">               split_range.<span class="built_in">begin</span>(), split_range.<span class="built_in">end</span>());</span><br><span class="line marked">    <span class="built_in">CHECK</span>(<span class="built_in">SetPermissions</span>(page_allocator, split_range.<span class="built_in">begin</span>(),</span><br><span class="line marked">                         split_range.<span class="built_in">size</span>(),</span><br><span class="line marked">                         PageAllocator::kReadWriteExecute));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WasmCodeAllocator::InsertIntoWritableRegions()</code> calls <code>SetPermissions()</code> to set the permission of the <code>region</code> to RWX.</p><p>This mechanism prevents us from writing our shellcode to the code space, as in part 1, because the write permission is expected not to be set when we attempt to write.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_src = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>]); <span class="comment">// wat2wasm pwn.wat</span></span><br><span class="line"><span class="keyword">let</span> wasm_module = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_src);</span><br></pre></td></tr></table></figure><p>With <code>--trace-wasm-native-heap</code> execution flag enabled in debug build, we can trace allocations and permissions of the code space.</p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/1.png"></p><p>However, <code>CodeSpaceWriteScope::SetExecutable()</code> checks <code>FLAG_wasm_write_protect_code_memory</code> every time it’s called. If we can overwrite the flag to <code>false</code> at runtime, the feature is expected to be disabled immediately, and we can achieve arbitrary code execution in the same way as part 1.</p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/2.png"></p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><h3 id="Getting-address-of-FLAG-wasm-write-protect-code-memory"><a href="#Getting-address-of-FLAG-wasm-write-protect-code-memory" class="headerlink" title="Getting address of FLAG_wasm_write_protect_code_memory"></a>Getting address of FLAG_wasm_write_protect_code_memory</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECL_PRIMITIVE_ACCESSORS</span>(isolate_root, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">V</span>(kIsolateRootOffset, kSystemPointerSize)                               \</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;execution&#x2F;isolate.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class contains a collection of data accessible from both C++ runtime</span></span><br><span class="line"><span class="comment">// and compiled code (including assembly stubs, builtins, interpreter bytecode</span></span><br><span class="line"><span class="comment">// handlers and optimized code).</span></span><br><span class="line">IsolateData isolate_data_;</span><br></pre></td></tr></table></figure><p><code>WasmInstanceObject</code> has an accessor named <code>isolate_root</code> that points to <code>isolate_data_</code>.</p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/3.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasm_module);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(wasm_instance);</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/4.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/5.png"></p><figure class="highlight c++"><figcaption><span>src&#x2F;execution&#x2F;isolate-data.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">ExternalReferenceTable external_reference_table_;</span><br></pre></td></tr></table></figure><p><code>IsolateData</code> has <code>external_reference_table_</code>, which contains a pointer to an execution flag of <code>d8</code>.</p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/6.png"></p><p>The order of the execution flags is consistent unless the V8 version is changed.</p><figure class="highlight c++"><figcaption><span>src&#x2F;flags&#x2F;flag-definitions.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">897</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_BOOL</span>(trace_osr, <span class="literal">false</span>, <span class="string">&quot;trace on-stack replacement&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;flags&#x2F;flag-definitions.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">980</span><br><span class="line">981</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_BOOL</span>(wasm_write_protect_code_memory, <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;write protect code memory on the wasm native heap with mprotect&quot;</span>)</span><br></pre></td></tr></table></figure><p>Therefore, we can reliably obtain the address of <code>FLAG_wasm_write_protect_code_memory</code> from the address of <code>FLAG_trace_osr</code>.</p><h3 id="Disabling-code-protection-and-executing-shellcode"><a href="#Disabling-code-protection-and-executing-shellcode" class="headerlink" title="Disabling code protection and executing shellcode"></a>Disabling code protection and executing shellcode</h3><p>We can overwrite <code>FLAG_wasm_write_protect_code_memory</code> to <code>false</code> using the unsandboxed AAW primitive. If so, the write permission of the WebAssembly code space is never removed thereafter.</p><p>Afterwards, we can achieve arbitrary code execution by overwriting the code space with shellcode, just like in part 1.</p><p><a href="empty.wat"><code>empty.wat</code></a> <a href="pwn.wat"><code>pwn.wat</code></a> <a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn.js"><code>pwn.js</code></a></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-2/pwn.png"></p><h2 id="Bisection"><a href="#Bisection" class="headerlink" title="Bisection"></a>Bisection</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)</p><p>Even though this is not a perfect protection, it will make it harder to write to the wasm code space because it’s not permanently RWX.</p><p>After optimizations (see <a href="https://crbug.com/v8/11974">https://crbug.com/v8/11974</a>) the performance is good enough that it’s worth just enabling it.</p></blockquote><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/48481a671ac7fed873f8a7e7203862beb6d89abd">[sandbox] Enable sandboxed pointers on Desktop</a> (May 05, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/c50b995e4b57558745aef9dda73dc58c57681811">Revert “[sandbox] Enable sandboxed pointers on Desktop”</a> (May 06, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/31d7838094a853556f345367038fe13252ea9224">Reland “[sandbox] Enable sandboxed pointers on Desktop”</a> (May 06, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/91ab0528f23aaf4d65ae86b7cafdcac65cff6c37">Revert “Reland “[sandbox] Enable sandboxed pointers on Desktop””</a> (May 06, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/9a6a76bf13d3ca1c6788de193afc5513919dd0ed">Reland “Reland “[sandbox] Enable sandboxed pointers on Desktop””</a> (May 10, 2022)</p></blockquote><p>The above commits enabled <code>v8_enable_sandboxed_pointers</code> by default when <code>v8_enable_sandbox</code> is enabled, resulting in the <code>external_pointer</code> of <code>TypedArray</code> not being stored as an 8-byte full pointer.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/5b9401dde4532719220ac698eef7012cdd371903">[sandbox] Also enable the sandbox outside of Chromium builds</a> (Jun 17, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/c878117fa0a848be0f011f410210ac4026baec05">Revert “[sandbox] Also enable the sandbox outside of Chromium builds”</a> (Jun 20, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/a4d17470ab23b057327d614d032fc05ef70dd683">Reland “[sandbox] Also enable the sandbox outside of Chromium builds”</a> (Jun 21, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/a7329344e52a0af3461aacaa8c538ddf8992e0d6">[sandbox] Disable the sandbox by default outside of Chromium builds</a> (Jul 19, 2022)</p><p><a href="https://chromium.googlesource.com/v8/v8.git/+/a8c27fcc9f9f15a0110a409190a2b514ec86e37f">[sandbox] Enable the sandbox by default in V8 builds</a> (Sep 23, 2022)</p></blockquote><p><code>v8_enable_sandbox</code> was enabled by default for standalone V8 builds in the above commits, whereas it was already enabled in Chromium builds in the following commit.</p><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/4fb3eae7afa2023057818d11faeefc031b78d444">Turn on v8_enable_virtual_memory_cage for Chromium builds</a> (Oct 4, 2021)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
          <category> exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Escaping V8 Sandbox via TypedArray and WebAssembly Code Space: Part 1 (V8 &lt; 10.0.138)</title>
      <link href="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/"/>
      <url>/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/</url>
      
        <content type="html"><![CDATA[<p>In this post, I will introduce an exploit technique that allows us to escape the V8 sandbox via <code>TypedArray</code> and WebAssembly code space, when we have some essential sandboxed exploit primitives.</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>Ubuntu 20.04</li><li><a href="https://chromium.googlesource.com/v8/v8.git/+/0ac7e1203fcb957851887fb140dc8a41139846a5">0ac7e1203fcb957851887fb140dc8a41139846a5</a> (Feb 15, 2022)</li></ul><p>Place <a href="v8setup.py"><code>v8setup.py</code></a> and <a href="sandbox.diff"><code>sandbox.diff</code></a> in your working directory, then run <code>v8setup.py</code>.</p><p><code>sandbox.diff</code> is identical to the change in <a href="https://chromium.googlesource.com/v8/v8.git/+/4a12cb1022ba335ce087dcfe31b261355524b3bf">[sandbox] Add new Memory Corruption API</a> (May 20, 2022), which introduced a new memory corruption API that allows us to simulate a vulnerability and implement essential exploit primitives within the sandbox.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="Data-pointer-of-TypedArray"><a href="#Data-pointer-of-TypedArray" class="headerlink" title="Data pointer of TypedArray"></a>Data pointer of TypedArray</h3><p><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray"><code>TypedArray</code></a> in JavaScript is managed by the <code>JSTypedArray</code> class.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-array-buffer.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSTypedArray</span> extends JSArrayBufferView &#123;</span><br><span class="line">  length: uintptr;</span><br><span class="line">  <span class="comment">// A SandboxedPtr if the sandbox is enabled</span></span><br><span class="line marked">  external_pointer: RawPtr;</span><br><span class="line marked">  base_pointer: ByteArray|Smi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JSTypedArray</code> has two kinds of pointers. <code>external_pointer</code> holds the address of the external array that actually contains the elements of the <code>TypedArray</code>, and <code>base_pointer</code> holds the distance between the <code>external_pointer</code> and the actual address where the first element is stored.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(<span class="number">1</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0x4141414141414141n</span>;</span><br><span class="line">% <span class="title class_">DebugPrint</span>(arr);</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/1.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/2.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/3.png"></p><p>When the <code>TypedArray</code> tries to read or write its elements, it adds its <code>external_pointer</code> and <code>base_pointer</code> and accesses the resulting address.</p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/4.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/5.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/6.png"></p><p>It doesn’t check whether the address is within the sandbox, so we can escape it by overwriting the <code>external_pointer</code> with an arbitrary address, using the sandboxed arbitrary address write primitive. In addition, we can leak the original <code>external_pointer</code> to obtain the base address of the V8 heap if needed, using the sandboxed arbitrary address read primitive.</p><h3 id="Execution-flow-of-WebAssembly-function"><a href="#Execution-flow-of-WebAssembly-function" class="headerlink" title="Execution flow of WebAssembly function"></a>Execution flow of WebAssembly function</h3><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try up to two times; getting rid of dead JSArrayBuffer allocations might</span></span><br><span class="line"><span class="comment">// require two GCs because the first GC maybe incremental and may have</span></span><br><span class="line"><span class="comment">// floating garbage.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kAllocationRetries = <span class="number">2</span>;</span><br><span class="line">VirtualMemory code_space;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> retries = <span class="number">0</span>;; ++retries) &#123;</span><br><span class="line marked">  code_space = <span class="built_in">TryAllocate</span>(code_vmem_size);</span><br><span class="line">  <span class="keyword">if</span> (code_space.<span class="built_in">IsReserved</span>()) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (retries == kAllocationRetries) &#123;</span><br><span class="line">    V8::<span class="built_in">FatalProcessOutOfMemory</span>(isolate, <span class="string">&quot;NewNativeModule&quot;</span>);</span><br><span class="line">    <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Run one GC, then try the allocation again.</span></span><br><span class="line">  isolate-&gt;<span class="built_in">heap</span>()-&gt;<span class="built_in">MemoryPressureNotification</span>(MemoryPressureLevel::kCritical,</span><br><span class="line">                                              <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When a WebAssembly module is created, <code>code_space</code> for the module is allocated.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needs_jump_table) &#123;</span><br><span class="line marked">  jump_table = <span class="built_in">CreateEmptyJumpTableInRegionLocked</span>(</span><br><span class="line marked">      JumpTableAssembler::<span class="built_in">SizeForNumberOfSlots</span>(num_wasm_functions), region);</span><br><span class="line">  <span class="built_in">CHECK</span>(region.<span class="built_in">contains</span>(jump_table-&gt;<span class="built_in">instruction_start</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At the very front of the code space, <code>jump_table</code> for the WebAssembly functions is created. The jump table is responsible for determining the execution flow of the functions.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-code-manager.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Even when we employ W^X with FLAG_wasm_write_protect_code_memory == true,</span></span><br><span class="line"><span class="comment">// code pages need to be initially allocated with RWX permission because of</span></span><br><span class="line"><span class="comment">// concurrent compilation/execution. For this reason there is no distinction</span></span><br><span class="line"><span class="comment">// here based on FLAG_wasm_write_protect_code_memory.</span></span><br><span class="line"><span class="comment">// TODO(dlehmann): This allocates initially as writable and executable, and</span></span><br><span class="line"><span class="comment">// as such is not safe-by-default. In particular, if</span></span><br><span class="line"><span class="comment">// &#123;WasmCodeAllocator::SetWritable(false)&#125; is never called afterwards (e.g.,</span></span><br><span class="line"><span class="comment">// because no &#123;CodeSpaceWriteScope&#125; is created), the writable permission is</span></span><br><span class="line"><span class="comment">// never withdrawn.</span></span><br><span class="line"><span class="comment">// One potential fix is to allocate initially with kReadExecute only, which</span></span><br><span class="line"><span class="comment">// forces all compilation threads to add the missing &#123;CodeSpaceWriteScope&#125;s</span></span><br><span class="line"><span class="comment">// before modification; and/or adding DCHECKs that &#123;CodeSpaceWriteScope&#125; is</span></span><br><span class="line"><span class="comment">// open when calling this method.</span></span><br><span class="line marked">PageAllocator::Permission permission = PageAllocator::kReadWriteExecute;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> success;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">MemoryProtectionKeysEnabled</span>()) &#123;</span><br><span class="line">  <span class="built_in">TRACE_HEAP</span>(</span><br><span class="line">      <span class="string">&quot;Setting rwx permissions and memory protection key %d for 0x%&quot;</span> PRIxPTR</span><br><span class="line">      <span class="string">&quot;:0x%&quot;</span> PRIxPTR <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">      memory_protection_key_, region.<span class="built_in">begin</span>(), region.<span class="built_in">end</span>());</span><br><span class="line">  success = <span class="built_in">SetPermissionsAndMemoryProtectionKey</span>(</span><br><span class="line">      <span class="built_in">GetPlatformPageAllocator</span>(), region, permission, memory_protection_key_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">TRACE_HEAP</span>(<span class="string">&quot;Setting rwx permissions for 0x%&quot;</span> PRIxPTR <span class="string">&quot;:0x%&quot;</span> PRIxPTR <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">             region.<span class="built_in">begin</span>(), region.<span class="built_in">end</span>());</span><br><span class="line">  success = <span class="built_in">SetPermissions</span>(<span class="built_in">GetPlatformPageAllocator</span>(), region.<span class="built_in">begin</span>(),</span><br><span class="line">                           region.<span class="built_in">size</span>(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The permission of the code space is set to RWX because compiled code for the WebAssembly functions has to be written and executed in that space.</p><figure class="highlight plaintext"><figcaption><span>test.wat</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(module</span><br><span class="line">  (func $f1 (export &quot;f1&quot;))</span><br><span class="line">  (func $f2 (export &quot;f2&quot;))</span><br><span class="line">  (func $f3 (export &quot;f3&quot;))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>test.wat</code> defines a WebAssembly module containing three functions, all of which are exported to JavaScript.</p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/7.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_src = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">102</span>, <span class="number">49</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">102</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">102</span>, <span class="number">51</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_module = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_src);</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/8.png"></p><p>The jump table consists of <code>jmp</code> instructions, each of which corresponds to a function in the module.</p><p>We can access the exported functions with <a href="https://developer.mozilla.org/docs/WebAssembly/Reference/JavaScript_interface/Instance/exports"><code>WebAssembly.Instance.prototype.exports</code></a>.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasm_module);</span><br><span class="line">% <span class="title class_">DebugPrint</span>(wasm_instance.<span class="property">exports</span>);</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/9.png"></p><p>Each function is managed by <code>JSFunction</code> class, like any other ordinary JavaScript function.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;js-function.tq</span></figcaption><table><tr><td class="gutter"><pre><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This class does not use the generated verifier, so if you change anything</span></span><br><span class="line"><span class="comment">// here, please also update JSFunctionVerify in objects-debug.cc.</span></span><br><span class="line">@highestInstanceTypeWithinParentClassRange</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">class</span> <span class="title class_">JSFunction</span> extends JSFunctionOrBoundFunction &#123;</span><br><span class="line">  shared_function_info: SharedFunctionInfo;</span><br><span class="line">  context: Context;</span><br><span class="line">  feedback_cell: FeedbackCell;</span><br><span class="line marked">  @<span class="keyword">if</span>(V8_EXTERNAL_CODE_SPACE) code: CodeDataContainer;</span><br><span class="line">  @ifnot(V8_EXTERNAL_CODE_SPACE) code: Code;</span><br><span class="line">  <span class="comment">// Space for the following field may or may not be allocated.</span></span><br><span class="line">  prototype_or_initial_map: JSReceiver|Map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JSFunction</code> has an accessor named <code>code</code> pointing to <code>CodeDataContainer</code>.</p><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;code.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cached value of code().InstructionStart().</span></span><br><span class="line"><span class="comment">// Available only when V8_EXTERNAL_CODE_SPACE is defined.</span></span><br><span class="line"><span class="built_in">DECL_GETTER</span>(code_entry_point, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;objects&#x2F;code.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">InstructionStart</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">raw_instruction_start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alias for code_entry_point to make it API compatible with Code.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Address <span class="title">entry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><code>CodeDataContainer</code> has an accessor named <code>code_entry_point</code> pointing to where the instruction pointer moves when the function is called.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">% <span class="title class_">DebugPrint</span>(wasm_instance.<span class="property">exports</span>.<span class="property">f3</span>);</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/10.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/11.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wasm_instance.<span class="property">exports</span>.<span class="title function_">f3</span>();</span><br></pre></td></tr></table></figure><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/12.png"></p><p>At this point, <code>rdi</code> holds the address of the <code>Function</code> object. The instructions from here get the call target corresponding to the function.</p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/13.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/14.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/15.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/16.png"></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/17.png"></p><p>The instruction pointer eventually moves to the third entry in the jump table, which corresponds to <code>f3()</code>, the function we called.</p><p>The <code>WasmInternalFunction</code> object is within the sandbox, so we can overwrite the call target with an arbitrary address to control the execution flow, using the sandboxed arbitrary address write primitive.</p><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><h3 id="Implementing-sandboxed-exploit-primitives"><a href="#Implementing-sandboxed-exploit-primitives" class="headerlink" title="Implementing sandboxed exploit primitives"></a>Implementing sandboxed exploit primitives</h3><p>The memory corruption API allows us to simulate a bug that can be exploited to implement sandboxed exploit primitives.</p><p>We can use <code>Sandbox.getAddressOf()</code> that returns the compressed address of a JavaScript object, to implement <code>addrof()</code> primitive. And we can use <code>Sandbox.MemoryView()</code> that returns an <code>ArrayBuffer</code> pointing to an arbitrary address within the sandbox, to implement sandboxed arbitrary address read&#x2F;write primitives.</p><h3 id="Implementing-unsandboxed-AAR-AAW"><a href="#Implementing-unsandboxed-AAR-AAW" class="headerlink" title="Implementing unsandboxed AAR&#x2F;AAW"></a>Implementing unsandboxed AAR&#x2F;AAW</h3><p>We can get the address of a <code>TypedArray</code> using the <code>addrof()</code> primitive, and overwrite the <code>external_pointer</code> and <code>base_pointer</code> using the sandboxed AAW primitive. If we set the <code>base_pointer</code> to 0 and the <code>external_pointer</code> to an arbitrary 8-byte address, we can read or write the value at that address via the <code>TypedArray</code>.</p><h3 id="Getting-address-of-WebAssembly-jump-table"><a href="#Getting-address-of-WebAssembly-jump-table" class="headerlink" title="Getting address of WebAssembly jump table"></a>Getting address of WebAssembly jump table</h3><p>We can use <a href="https://developer.mozilla.org/docs/WebAssembly/Reference/JavaScript_interface/Instance/Instance"><code>WebAssembly.Instance()</code></a> constructor to create a WebAssembly instance from the WebAssembly module. The WebAssembly instance is managed by <code>WasmInstanceObject</code> class.</p><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECL_PRIMITIVE_ACCESSORS</span>(jump_table_start, Address)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>src&#x2F;wasm&#x2F;wasm-objects.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">386</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">V</span>(kJumpTableStartOffset, kSystemPointerSize)                            \</span><br></pre></td></tr></table></figure><p><code>WasmInstanceObject</code> has an accessor named <code>jump_table_start</code> that holds the address of the jump table for the module. We can get the address of the <code>WasmInstanceObject</code> using the <code>addrof()</code> primitive, and read the value at the <code>jump_table_start</code> field using the AAR primitive.</p><h3 id="Executing-shellcode"><a href="#Executing-shellcode" class="headerlink" title="Executing shellcode"></a>Executing shellcode</h3><p>To put it simply, the instruction pointer moves to the address of the jump table when we call the first function in the module. We can overwrite the jump table with our shellcode so that it’s executed when the function is called.</p><p><a href="pwn.wat"><code>pwn.wat</code></a> <a href="shellcode.py"><code>shellcode.py</code></a> <a href="pwn.js"><code>pwn.js</code></a></p><p><img src="/escaping-v8-sandbox-via-typedarray-and-webassembly-code-space-part-1/pwn.png"></p><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><blockquote><p><a href="https://chromium.googlesource.com/v8/v8.git/+/f759872d52093d1ac2b531f7e8fa956264b57ad9">[wasm] Ship code protection via mprotect</a> (Feb 15, 2022)<br>Even though this is not a perfect protection, it will make it harder to write to the wasm code space because it’s not permanently RWX.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> n-day </category>
          
          <category> exploit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> chromium </tag>
            
            <tag> v8 </tag>
            
            <tag> v8sbx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
